//-----------------------------------------------------------------------------
// FILE:        SilverlightCommand.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:   Copyright (c) 2005-2015 by Jeffrey Lill. All rights reserved.
// DESCRIPTION: Implements the SILVERLIGHT commands.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;

using LillTek.Common;

namespace LillTek.Tools.Vegomatic
{
    /// <summary>
    /// Implements the SILVERLIGHT commands.
    /// </summary>
    public static class SilverlightCommand
    {
        /// <summary>
        /// Executes the specified SILVERLIGHT command.
        /// </summary>
        /// <param name="args">The command arguments.</param>
        /// <returns>0 on success, a non-zero error code otherwise.</returns>
        public static int Execute(string[] args)
        {
            const string usage =
@"
Usage: 

-------------------------------------------------------------------------------
vegomatic silverlight webproxy -baseProxy:<baseProxy> 
                               -enhancedProxy:<enhancedProxy>
                               -output:<output>
                               [-namespace:<namespace>]
                               [-replace:<replace file>

Generates an enhanced web service proxy class for Silverlight applications
from a proxy class generated by Visual Studio.  The enhanced proxy provides
better support for complex and modular applications.

arguments:  <baseProxy>         path to the base proxy source file generated
                                by Visual Studio

            <enhancedProxy>     fully qualified name of the enhanced proxy 
                                class to be generated

            <output>            the path where the generated enhanced proxy
                                C# source should be written

            <namespace>         optionally specifies the namespace to be used
                                rather than the default namespace generated by 
                                SvcUtil.

            <replace file>      an optional text file that specifies a 
                                list of classes to be deleted from the source
                                proxy file as well as the type to subsitite
                                for all references.

The current implementation of this command is somewhat crude because it 
depends on the base proxy source generated by Visual Studio to be 
formated in a particular way.  The tool will need to be updated
whenever Visual Studio changes how it generates proxies.

The optional -namespace option can be used to override the default namespace
generated by the built-in Visual Studio web service proxy generator.  If this
is present, the tool will use this value to overwrite the namespace definition
for the source file as well as the generated output file.

The optional -replace option is used to remove classes from the source proxy
file.  This is necessary in situations where the Visual Studio proxy generator
wan't able to reuse an existing type properly.  <replace file> should be the
path of a text file that specifies the fully qualified name of the classes
to be removed as well as the fully qualified names of the classes to be
substituted.  The file formatted one replacement per line as in:

    <existing type>  -->  <new type>

Blank lines and lines that begin with # are ignored.  The example below
specifies that existing types Proxy.MyClass1 and Proxy.MyClass2 are to be
removed and any references replaced by Test.MyClass1 and Test.MyClass2:

    Proxy.MyClass1  -->  Test.MyClass1
    Proxy.MyClass2  -->  Test.MyClass2
";
            if (args.Length < 1)
            {
                Program.Error(usage);
                return 1;
            }

            switch (args[0].ToLowerInvariant())
            {
                case "webproxy":

                    return WebProxy(args);

                default:

                    Program.Error(usage);
                    return 1;
            }
        }

        /// <summary>
        /// Describes a method parameter.
        /// </summary>
        private class Parameter
        {
            /// <summary>
            /// The parameter type.
            /// </summary>
            public string Type { get; set; }

            /// <summary>
            /// The parameter name.
            /// </summary>
            public string Name { get; set; }
        }

        /// <summary>
        /// Holds the information gleaned from the Visual Studio web service
        /// proxy file about an operation that will be necessary for generating 
        /// the enhanced proxy.
        /// </summary>
        private class ProxyMethod
        {
            /// <summary>
            /// The method name.
            /// </summary>
            public string Name { get; set; }

            /// <summary>
            /// The method's result type.
            /// </summary>
            public string ResultType { get; set; }

            /// <summary>
            /// The method parameters.
            /// </summary>
            public List<Parameter> Parameters { get; set; }

            /// <summary>
            /// Constructor.
            /// </summary>
            public ProxyMethod()
            {
                this.Parameters = new List<Parameter>();
            }
        }

        /// <summary>
        /// Information from a Visual Studio generated proxy source file.
        /// </summary>
        private class VSProxyInfo
        {
            /// <summary>
            /// The original proxy namespace.
            /// </summary>
            public string OriginalProxyNamespace { get; set; }

            /// <summary>
            /// The generated proxy namespace.
            /// </summary>
            public string ProxyNamespace { get; set; }

            /// <summary>
            /// The generated proxy class name.
            /// </summary>
            public string ProxyClassName { get; set; }

            /// <summary>
            /// The generated proxy methods.
            /// </summary>
            public List<ProxyMethod> Methods { get; set; }

            /// <summary>
            /// Constructor.
            /// </summary>
            public VSProxyInfo()
            {
                this.Methods = new List<ProxyMethod>();
            }
        }

        /// <summary>
        /// Parses the proxy source file generated by Visual Studio for Silverlight
        /// applications and returns information necessary to generate the enhanced
        /// proxy.
        /// </summary>
        /// <param name="path">Path too the Visual Studio generated proxy source file.</param>
        /// <returns>The proxy information.</returns>
        private static VSProxyInfo ParseVSProxySource(string path)
        {
            const string BadSource = "Cannot parse Visual Studio generated proxy source file.";

            VSProxyInfo     proxyInfo = new VSProxyInfo();
            string          line;
            int             p, pEnd;

            using (var reader = new StreamReader(path, Helper.AnsiEncoding))
            {
                // Scan for the namespace

                line = reader.ReadLine();
                while (line != null && !line.StartsWith("namespace"))
                    line = reader.ReadLine();

                if (line == null)
                    throw new FormatException(BadSource);

                pEnd = line.IndexOf('{');
                if (pEnd == -1)
                    throw new FormatException(BadSource);

                proxyInfo.OriginalProxyNamespace =
                proxyInfo.ProxyNamespace         = line.Substring(10, pEnd - 10).Trim();

                // Scan for the proxy class

                line = reader.ReadLine();
                while (line != null && line.IndexOf(" : System.ServiceModel.ClientBase<") == -1)
                    line = reader.ReadLine();

                if (line == null)
                    throw new FormatException(BadSource);

                p    = line.IndexOf("public partial class");
                p   += "public partial class".Length;
                pEnd = line.IndexOf(':');
                proxyInfo.ProxyClassName = line.Substring(p, pEnd - p).Trim();

                // Scan for the method definitions (except for the ResultType).

                for (; line != null; line = reader.ReadLine())
                {
                    p = line.IndexOf("public void");
                    if (p == -1)
                        continue;

                    if (line.IndexOf("object userState)") != -1)
                        continue;

                    pEnd = line.IndexOf('(');
                    if (pEnd == -1)
                        throw new FormatException(BadSource);

                    ProxyMethod method = new ProxyMethod();

                    p += 11;
                    method.Name = line.Substring(p, pEnd - p).Trim();
                    method.Name = method.Name.Substring(0, method.Name.Length - "Async".Length);

                    if (method.Name == "Open" || method.Name == "Close")
                        continue;   // The "OpenAsync()" and "CloseAsync" methods are helpers generated 
                                    // for the application's local use and are not actually web service
                                    // methods so we'll ignore them.

                    p = pEnd;
                    pEnd = line.IndexOf(')');
                    if (pEnd == -1)
                        throw new FormatException(BadSource);

                    p++;
                    line = line.Substring(p, pEnd - p);

                    // Parse the parameters.  Note that I need to take care to parse generic
                    // type parameters properly.

                    string      paramType;
                    string      paramName;
                    char        ch;

                    p = 0;
                    while (true)
                    {
                        paramType = string.Empty;
                        paramName = string.Empty;

                        // Parse the parameter type

                        while (p < line.Length && line[p] == ' ')       // Skip whitespace
                            p++;

                        if (p == line.Length)
                            break;

                        while (p < line.Length)
                        {
                            ch = line[p++];
                            if (ch == ' ')
                                break;
                            else if (ch == '<')
                            {
                                // We have generic type parameters.  Continue parsing until
                                // we encounter the closing ">", taking any nesting into account.

                                int nesting = 1;

                                paramType += ch;
                                while (p < line.Length)
                                {
                                    ch = line[p++];
                                    paramType += ch;

                                    if (ch == '<')
                                        nesting++;
                                    else if (ch == '>')
                                        nesting--;

                                    if (nesting == 0)
                                        break;
                                }

                                if (nesting > 0)
                                    throw new FormatException(BadSource);

                                break;
                            }
                            else
                                paramType += ch;
                        }

                        // Parse the parameter name

                        while (p < line.Length && line[p] == ' ')       // Skip whitespace
                            p++;

                        if (p == line.Length)
                            throw new FormatException(BadSource);

                        pEnd = line.IndexOf(',', p);
                        if (pEnd == -1)
                            paramName = line.Substring(p).Trim();
                        else
                            paramName = line.Substring(p, pEnd - p).Trim();

                        method.Parameters.Add(new Parameter() { Type = paramType, Name = paramName });

                        if (pEnd == -1)
                            break;

                        p = pEnd + 1;
                    }

                    proxyInfo.Methods.Add(method);
                }
            }

            // Rescan the source file looking for the method result types.  I'm going to get this
            // from the Result property of the method's xxxCompletedEventArgs class definition.

            using (var reader = new StreamReader(path, Helper.AnsiEncoding))
            {
                for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                {
                    string methodName;
                    string resultType;

                    line = line.Trim();
                    if (!line.StartsWith("public partial class ") || !line.EndsWith(" : System.ComponentModel.AsyncCompletedEventArgs {"))
                        continue;

                    // We have an event arguments declaration.  Extract the method name
                    // from the class name by trimming "CompletedEventArgs" from the end.

                    p = "public partial class ".Length;
                    pEnd = line.IndexOf(" : System.ComponentModel.AsyncCompletedEventArgs {");
                    methodName = line.Substring(p, pEnd - p).Trim();

                    if (!methodName.EndsWith("CompletedEventArgs"))
                        throw new FormatException(BadSource);

                    methodName = methodName.Substring(0, methodName.Length - "CompletedEventArgs".Length);

                    // Scan forward until we get to the "Result" property.

                    for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                    {
                        line = line.Trim();
                        if (line.StartsWith("public ") && line.EndsWith(" Result {"))
                            break;
                    }

                    if (line == null)
                        throw new FormatException(BadSource);

                    p = "public ".Length;
                    pEnd = line.Length - " Result {".Length;
                    resultType = line.Substring(p, pEnd - p).Trim();

                    // Update any records for methods with this name.  Note that there
                    // will be more than one method entry if methods have overrides.

                    foreach (var method in proxyInfo.Methods)
                        if (method.Name == methodName)
                            method.ResultType = resultType;
                }
            }

            // Verify that we found result types for all methods.

            foreach (var method in proxyInfo.Methods)
                if (method.ResultType == null)
                    throw new FormatException(BadSource);

            return proxyInfo;
        }

        /// <summary>
        /// Generates the enhanced proxy source file.
        /// </summary>
        /// <param name="proxyInfo">The gathered proxy information.</param>
        /// <param name="enhancedProxyName">The generated proxy name.</param>
        /// <param name="outputPath">The output file path.</param>
        private static void GenerateEnhancedProxy(VSProxyInfo proxyInfo, string enhancedProxyName, string outputPath)
        {
            using (var writer = new StreamWriter(new FileStream(outputPath, FileMode.Create), Helper.AnsiEncoding))
            {
                writer.WriteLine(@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by 
//
//     LillTek Vegomatic
//     version {0}
//     {1}
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
", Helper.GetVersion(Assembly.GetExecutingAssembly()), Helper.GetCopyright(Assembly.GetExecutingAssembly()));

                writer.WriteLine("using System;");
                writer.WriteLine();
                writer.WriteLine("using LillTek.Common;");
                writer.WriteLine();
                writer.WriteLine("namespace {0} {{", proxyInfo.ProxyNamespace);

                // Generate the finished event classes (one for each distinct method name).

                var generatedMethods = new Dictionary<string, bool>();

                foreach (var method in proxyInfo.Methods)
                {
                    if (generatedMethods.ContainsKey(method.Name))
                        continue;

                    generatedMethods.Add(method.Name, true);

                    writer.Write(@"
    [System.Diagnostics.DebuggerStepThroughAttribute]
    public sealed class {0}FinishedEventArgs : EventArgs {{

        private {0}CompletedEventArgs baseArgs;
        private object userState;

        public {0}FinishedEventArgs({0}CompletedEventArgs baseArgs,object userState) {{

            this.baseArgs  = baseArgs;
            this.userState = userState;
        }}

        public {1} Result {{

            get {{ return baseArgs.Result; }}
        }}

        public object UserState {{

            get {{ return userState; }}
        }}
    }}
", method.Name, method.ResultType);
                }

                // Generate the enhanced proxy class, its constructor and any built-in methods

                writer.Write(@"
    [System.Diagnostics.DebuggerStepThroughAttribute]
    public class {1} : IDisposable {{

        private {0} baseProxy;

        public {1}() {{

            baseProxy = new {0}();
            Initialize();
        }}

        public {1}(string endpointConfigurationName) {{

            baseProxy = new {0}(endpointConfigurationName);
            Initialize();
        }}
        
        public {1}(string endpointConfigurationName,string remoteAddress) {{

            baseProxy = new {0}(endpointConfigurationName,remoteAddress);
            Initialize();
        }}
        
        public {1}(string endpointConfigurationName,System.ServiceModel.EndpointAddress remoteAddress) {{

            baseProxy = new {0}(endpointConfigurationName,remoteAddress);
            Initialize();
        }}
        
        public {1}(System.ServiceModel.Channels.Binding binding,System.ServiceModel.EndpointAddress remoteAddress) {{

            baseProxy = new {0}(binding,remoteAddress);
            Initialize();
        }}

        public void Close() {{

            if (baseProxy != null) {{

                baseProxy.CloseAsync();
                baseProxy = null;
            }}
        }}

        public void Dispose() {{

            Close();
        }}
", proxyInfo.ProxyClassName, enhancedProxyName);

                // Generate the Initialize() method that adds event handlers for
                // all of the base proxy's async methods

                writer.WriteLine("        private void Initialize() {");
                writer.WriteLine();

                foreach (var method in proxyInfo.Methods)
                    writer.WriteLine("            baseProxy.{0}Completed += new EventHandler<{0}CompletedEventArgs>(On{0}Completed);", method.Name);

                writer.WriteLine("        }");

                // Generate the completion event handler for each method

                generatedMethods.Clear();

                foreach (var method in proxyInfo.Methods)
                {
                    if (generatedMethods.ContainsKey(method.Name))
                        continue;

                    generatedMethods.Add(method.Name, true);

                    writer.Write(@"
        private void On{0}Completed(object sender,{0}CompletedEventArgs baseArgs) {{

            if (baseProxy == null)
                return;

            AsyncCallState  callState = (AsyncCallState) baseArgs.UserState;

            if (callState.Context != null && callState.Context.AsyncContextID != callState.OrgContextID)
                return;

            callState.Callback.DynamicInvoke(this,new {0}FinishedEventArgs(baseArgs,callState.UserState));
        }}
", method.Name);
                }

                // Generate two async method stubs for each proxy methods, one without a user state parameter
                // and one with one.

                foreach (var method in proxyInfo.Methods)
                {
                    string paramDef = string.Empty;
                    string paramVal = string.Empty;

                    foreach (var arg in method.Parameters)
                    {
                        if (paramDef.Length > 0)
                        {
                            paramDef += ',';
                            paramVal += ",";
                        }

                        paramDef += arg.Type + " " + arg.Name;
                        paramVal += arg.Name;
                    }

                    if (paramDef.Length > 0)
                        paramDef += ",";

                    if (paramVal.Length > 0)
                        paramVal += ",";

                    writer.WriteLine(@"
        public void {0}Async({1}EventHandler<{0}FinishedEventArgs> callback) {{

            {0}Async({2}callback,null);
        }}

        public void {0}Async({1}EventHandler<{0}FinishedEventArgs> callback,object userState) {{

            IAsyncContext   context      = callback.Target as IAsyncContext;
            int             orgContextID = 0;

            if (context != null)
                orgContextID = context.AsyncContextID;

            baseProxy.{0}Async({2}new AsyncCallState() {{ Context=context, OrgContextID=orgContextID, Callback=callback, UserState=userState}});
        }}", method.Name, paramDef, paramVal);
                }

                // Close out the proxy class and the namespace

                writer.WriteLine("    }");
                writer.WriteLine("}");
            }
        }

        /// <summary>
        /// Determines whether a character is a valid identify character or namespace separator.
        /// </summary>
        /// <param name="ch">The character to be tested.</param>
        /// <returns><c>true</c> if the character belongs in an identifier.</returns>
        private static bool IsIdentChar(char ch)
        {
            return ch == '.' || Char.IsLetterOrDigit(ch) || ch == '_';
        }

        /// <summary>
        /// Verifies that the identifier at the specified position in a line of text
        /// actually matches the identifer passed.
        /// </summary>
        /// <param name="line">The line of text.</param>
        /// <param name="pos">The position.</param>
        /// <param name="ident">The identifier to be matched.</param>
        /// <returns><c>true</c> if there's a match.</returns>
        private static bool VerifyIdent(string line, int pos, string ident)
        {
            // Basically all we're doing here is verifying that the identifier
            // passed is not a substring of the identifier found by making
            // sure that the first character before the matching sequence is not
            // a valid identifier character or a namespace separator and also
            // that the first character after the matching sequence is
            // not a valid identfier character or a namespace separator (period).
            // This is a bit of a hack but should work most of the time.

            if (pos > 0 && IsIdentChar(line[pos - 1]))
                return false;

            if (pos + ident.Length >= line.Length)
                return true;

            return !IsIdentChar(line[pos + ident.Length]);
        }

        /// <summary>
        /// Updates the base proxy source file by updating the namespace definition.
        /// </summary>
        /// <param name="baseProxyPath">Path to the base proxy source file.</param>
        /// <param name="namespaceOverride">The new namespace.</param>
        private static void UpdateBaseProxy(string baseProxyPath, string namespaceOverride)
        {
            string source;

            using (var reader = new StreamReader(baseProxyPath))
                source = reader.ReadToEnd();

            using (var writer = new StreamWriter(new FileStream(baseProxyPath, FileMode.Create), Helper.AnsiEncoding))
            {
                using (StringReader reader = new StringReader(source))
                {
                    string line;

                    // Copy all lines from the source to the output up to the
                    // first line that begins with "namespace ".

                    for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                        if (line.StartsWith("namespace "))
                            break;
                        else
                            writer.WriteLine(line);

                    if (line == null)
                        throw new FormatException("Cannot find the namespace definition in the proxy source file.");

                    // Write the new namespace

                    writer.WriteLine("namespace {0} {{", namespaceOverride);

                    // Copy the rest of the file to the output.

                    for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                        writer.WriteLine(line);
                }
            }
        }

        /// <summary>
        /// Rewrites the source file by replacing any type definitions using the old
        /// namespace with the new namespace.
        /// </summary>
        /// <param name="proxyInfo">The proxy information.</param>
        /// <param name="path">Path to the source file.</param>
        private static void MungeNamespace(VSProxyInfo proxyInfo, string path)
        {
            string source;
            string original;
            string replace;

            if (proxyInfo.OriginalProxyNamespace == proxyInfo.ProxyNamespace)
                return;     // Namespaces are the same

            original = proxyInfo.OriginalProxyNamespace + ".";  // Add the period to replace only usage in types
            replace  = proxyInfo.ProxyNamespace + ".";

            using (var reader = new StreamReader(path, Helper.AnsiEncoding))
                source = reader.ReadToEnd();

            using (var writer = new StreamWriter(new FileStream(path, FileMode.Create), Helper.AnsiEncoding))
            {
                using (var reader = new StringReader(source))
                {
                    for (string line = reader.ReadLine(); line != null; line = reader.ReadLine())
                    {
                        if (line == null)
                            break;

                        line = line.Replace(original, replace);
                        writer.WriteLine(line);
                    }
                }
            }
        }

        /// <summary>
        /// Rewrites the source file by replacing any type definitions matching the 
        /// old type with the new one.
        /// </summary>
        /// <param name="path">Path to the source file.</param>
        /// <param name="replacements">The collection of replacements keyed by old type.</param>
        private static void MungeTypes(string path, Dictionary<string, string> replacements)
        {
            string source;

            using (var reader = new StreamReader(path, Helper.AnsiEncoding))
                source = reader.ReadToEnd();

            using (var writer = new StreamWriter(new FileStream(path, FileMode.Create), Helper.AnsiEncoding))
            {
                using (var reader = new StringReader(source))
                {
                    for (string line = reader.ReadLine(); line != null; line = reader.ReadLine())
                    {
                        if (line == null)
                            break;

                        foreach (string oldType in replacements.Keys)
                        {
                            string newType = replacements[oldType];
                            int pos;

                            pos = line.IndexOf(oldType);
                            while (pos != -1)
                            {
                                if (VerifyIdent(line, pos, oldType))
                                {
                                    // $hack(jeff.lill)
                                    //
                                    // If the first non-whitespace after the identifier is a "{" then
                                    // it looks like we have a property definition with a property name
                                    // that matches the type name.  We'll skip the munge for this.

                                    bool isProperty = false;

                                    for (int i = pos + oldType.Length; i < line.Length; i++)
                                    {
                                        if (Char.IsWhiteSpace(line[i]))
                                            continue;
                                        else if (line[i] == '{')
                                        {
                                            isProperty = true;
                                            break;
                                        }
                                        else
                                            break;
                                    }

                                    if (isProperty)
                                        break;

                                    line = line.Substring(0, pos) + newType + line.Substring(pos + oldType.Length);
                                    pos += newType.Length;
                                }
                                else
                                {
                                    // Advance past any remaining ident chars

                                    pos += oldType.Length;
                                    while (pos < line.Length && IsIdentChar(line[pos]))
                                        pos++;

                                    if (pos >= line.Length)
                                        break;
                                }

                                // Look for another instance on this line

                                pos = line.IndexOf(oldType, pos);
                            }
                        }

                        writer.WriteLine(line);
                    }
                }
            }
        }

        /// <summary>
        /// Scans the source file for class definitions for any of the types in
        /// the laist passed and removes those definitions from the source file.
        /// </summary>
        /// <param name="path">The path to the source file.</param>
        /// <param name="list">The list fully qualified class names.</param>
        private static void RemoveClasses(string path, List<string> list)
        {
            const string BadSource = "Unexpected problems with the proxy source file.";

            // $hack(jeff.lill): #1
            //
            // I'm really hacking this for now by assuming that only classes
            // actually defined within the namespace of the source file will
            // be passed in the list.

            // Strip any namespace prefixes off the listed types.

            for (int i = 0; i < list.Count; i++)
            {
                string  type = list[i];
                int     pos;

                pos = type.LastIndexOf('.');
                if (pos != -1)
                    list[i] = type.Substring(pos + 1);
            }

            // $hack(jeff.lill): #2
            //
            // I'm assuming that classes that will be deleted are structured as:
            //
            //      [System.Diagnostics.DebuggerStepThroughAttribute()] 
            //      ... additional attributes ...
            //      public partial class Name ...
            //
            //          ... the class definition
            //      }
            //
            //      [System.Diagnostics.DebuggerStepThroughAttribute()] 
            //      ... the next class ...
            //
            //      ... or ...
            //
            //      [System.ServiceModel.ServiceContractAttribute(...)]
            //      ... which indicates an interface which will not be deleted     
            //
            // This also assumes that classes being deleted are never the last
            // class in the file (the proxy generator currently writes the service 
            // proxy last in the file, so this condition is true for VS2008).

            var     delTable = new Dictionary<string, bool>(); ;
            var     attributes = new List<string>();
            string  source;

            foreach (string type in list)
                delTable[type] = true;

            using (var reader = new StreamReader(path, Helper.AnsiEncoding))
                source = reader.ReadToEnd();

            using (var reader = new StringReader(source))
            {
                using (var writer = new StreamWriter(path, false, Helper.AnsiEncoding))
                {
                    string  line = null;
                    string  className;
                    int     p, pEnd;

                    while (true)
                    {
                    mainLoop:

                        // Copy lines to the output until we find a [DebuggerStepThroughAttribute].

                        for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                        {
                            if (line.Trim() == "[System.Diagnostics.DebuggerStepThroughAttribute()]")
                                break;

                            writer.WriteLine(line);
                        }

                        if (line == null)
                            break;      // We've reached the EOF so we're done

                        // Collect the class attributes

                        gotAttribute:

                        attributes.Clear();
                        attributes.Add(line);

                        for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                        {
                            if (line == null)
                                throw new FormatException(BadSource);
                            else if (line.Trim().StartsWith("["))
                                attributes.Add(line);
                            else
                                break;
                        }

                        // The current line should now be the class definition.  Extract the class
                        // name and see if it's one of the types to be deleted.

                        p = line.IndexOf(" class ");
                        if (p == -1)
                            throw new FormatException(BadSource);

                        p   += " class ".Length;
                        pEnd = p;

                        while (pEnd < line.Length && IsIdentChar(line[pEnd]))
                            pEnd++;

                        className = line.Substring(p, pEnd - p);
                        if (!delTable.ContainsKey(className))
                        {
                            // This class isn't being removed so write the accumulated attributes
                            // and the class definition.

                            for (int i = 0; i < attributes.Count; i++)
                                writer.WriteLine(attributes[i]);

                            writer.WriteLine(line);

                            // Loop to continue scanning for the next class

                            continue;
                        }

                        // We're deleting this class, so scan for the next [DebuggerStepThroughAttribute]
                        // in the source file which will mark the next class.  Note that we're depending
                        // on the fact that we'll never delete the last class in the source file.

                        for (line = reader.ReadLine(); line != null; line = reader.ReadLine())
                        {
                            if (line.Trim() == "[System.Diagnostics.DebuggerStepThroughAttribute()]")
                                goto gotAttribute;
                            else if (line.Trim().StartsWith("[System.ServiceModel.ServiceContractAttribute("))
                            {
                                // Looks like we have an interface definition.  We'll output the
                                // current line and then loop to output lines up to the next class.

                                writer.WriteLine(line);
                                goto mainLoop;
                            }
                        }

                        if (line == null)
                            throw new InvalidOperationException("Cannot delete the last class in the source file.");
                    }
                }
            }
        }

        // Hacks: This code is highly dependent on the format of the proxy 
        //        source code generated by Visual Studio.  Here's a list
        //        of the major dependencies:
        //
        //  * Root proxy class is identifyed by " : System.ServiceModel.ClientBase<"
        //  * Root proxy class is the last class in the source file
        //  * Operation declarations are formatted as "xxxxAsync(...)" on a single line
        //  * Completion events are named "xxxxCompleted".
        //  * Completion event arguments are named "xxxxCompletedEventArgs"

        private static int WebProxy(string[] _args)
        {
            try
            {
                CommandLine                 args              = new CommandLine(_args, false);
                string                      baseProxyPath     = args.GetOption("baseProxy", null);
                string                      enhancedProxyName = args.GetOption("enhancedProxy", null);
                string                      outputPath        = args.GetOption("output", null);
                string                      namespaceOverride = args.GetOption("namespace", null);
                string                      replacePath       = args.GetOption("replace", null);
                Dictionary<string, string>  replacements      = null;
                VSProxyInfo proxyInfo;

                if (baseProxyPath == null)
                    throw new Exception("-baseProxy: option is required.");

                if (baseProxyPath == null)
                    throw new Exception("-enhancedProxy: option is required.");

                if (outputPath == null)
                    throw new Exception("-output: option is required.");

                if (replacePath != null)
                {
                    replacements = new Dictionary<string, string>();

                    using (var reader = new StreamReader(replacePath, Helper.AnsiEncoding))
                    {
                        for (string line = reader.ReadLine(); line != null; line = reader.ReadLine())
                        {
                            line = line.Trim();
                            if (line.Length == 0 || line.StartsWith("#"))
                                continue;

                            string  oldType;
                            string  newType;
                            int     pos;

                            pos = line.IndexOf("-->");
                            if (pos == -1)
                                continue;

                            oldType = line.Substring(0, pos).Trim();
                            newType = line.Substring(pos + 3).Trim();

                            replacements[oldType] = newType;
                        }
                    }
                }

                Console.WriteLine("Parsing:         {0}", baseProxyPath);
                proxyInfo = ParseVSProxySource(baseProxyPath);

                if (namespaceOverride != null)
                    proxyInfo.ProxyNamespace = namespaceOverride;

                Console.WriteLine("Generating:      {0}", outputPath);
                GenerateEnhancedProxy(proxyInfo, enhancedProxyName, outputPath);

                if (namespaceOverride != null)
                {
                    Console.WriteLine("Updating:        {0}", baseProxyPath);
                    UpdateBaseProxy(baseProxyPath, namespaceOverride);
                    Console.WriteLine("Namespace Munge: {0}", baseProxyPath);
                    MungeNamespace(proxyInfo, baseProxyPath);
                    Console.WriteLine("Namespace Munge: {0}", outputPath);
                    MungeNamespace(proxyInfo, outputPath);
                }

                if (replacements != null)
                {
                    var list = new List<string>();

                    foreach (string key in replacements.Keys)
                        list.Add(key);

                    Console.WriteLine("Type Delete:     {0}", outputPath);
                    RemoveClasses(baseProxyPath, list);

                    Console.WriteLine("Type Munge:      {0}", baseProxyPath);
                    MungeTypes(baseProxyPath, replacements);
                    Console.WriteLine("Type Munge:      {0}", outputPath);
                    MungeTypes(outputPath, replacements);
                }
            }
            catch (Exception e)
            {
                Program.Error("Error ({0}): {1}", e.GetType().Name, e.Message);
                return 1;
            }
            finally
            {
            }

            return 0;
        }
    }
}
