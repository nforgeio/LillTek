//-----------------------------------------------------------------------------
// FILE:        UniqueVisitor.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:   Copyright (c) 2005-2015 by Jeffrey Lill.  All rights reserved.
// DESCRIPTION: Used to identify a unique visitor to a web site.

using System;
using System.IO;
using System.Net;
using System.Web;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections.Generic;

using LillTek.Common;
using LillTek.Advanced;
using LillTek.Service;

namespace LillTek.Web
{
    /// <summary>
    /// Used to identify a unique visitor to a web site.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This class is designed to be used in conjunction with <see cref="WebHelper.GetUniqueVisitor" /> to
    /// assign and obtain unique identifies for visitors to a web site using cookies.  Each visitor will
    /// be assigned a globally unique ID combined with the date/time (UTC) when the visitor was first
    /// encountered.
    /// </para>
    /// <para>
    /// The <see cref="UniqueVisitor()" /> constructor can be used to generate an instance for a new
    /// visitor and the <see cref="UniqueVisitor(string)" /> constructor for rehydrating an instance
    /// from a cookie value.  The <see cref="ID" /> property will return the visitors globally unique
    /// ID and <see cref="IssueDateUtc" /> the time the visitor was first encountered.
    /// </para>
    /// <para>
    /// Use <see cref="ToString" /> to serialize the instance into a base-64 encoded string suitable
    /// for using as and HTTP cookie value.
    /// </para>
    /// <para><u><b>Implementation Note</b></u></para>
    /// <para>
    /// The serialized format of the instance combines the 64-bit tick count of the issue date
    /// with the 32-byte GUID, plus a 16-bit magic number header.  This will be generated as a
    /// byte array and then rendered as a base-64 string.  Here's how this lays out:
    /// </para>
    /// <code language="none">
    /// +----------------+
    /// |     Magic      |      16-bits: 0xF1DD
    /// +----------------+
    /// |                |
    /// |  IssueDateUtc  |      64-bits: DateTime.Ticks value
    /// |                |
    /// +----------------+
    /// |                |
    /// |                |
    /// |                |
    /// |                |
    /// |      GUID      |      32-bytes: ID
    /// |                |
    /// |                |
    /// |                |
    /// |                |
    /// +----------------+
    /// </code>
    /// <para>
    /// Note that all multi-byte integers are written in network (big-endian) byte order.
    /// </para>
    /// </remarks>
    public class UniqueVisitor
    {
        private const int Magic = 0x000031DD;

        /// <summary>
        /// Constructs an instance with a globally unique ID and stamped with the current time.
        /// </summary>
        public UniqueVisitor()
        {
            this.ID           = Guid.NewGuid();
            this.IssueDateUtc = DateTime.UtcNow;
        }

        /// <summary>
        /// Constructs an instance by parsing a serialized string.
        /// </summary>
        /// <param name="serialized">The serialized visitor information.</param>
        /// <exception cref="ArgumentNullException">Thrown if <c>null</c> is passed.</exception>
        /// <exception cref="ArgumentException">Thrown if the parameter passed does not represent a valid <see cref="UniqueVisitor" /> instance.</exception>
        /// <remarks>
        /// <para>
        /// The <paramref name="serialized" /> value must have been generated by
        /// a previous call to <see cref="ToString" />.
        /// </para>
        /// </remarks>
        public UniqueVisitor(string serialized)
        {
            if (serialized == null)
                throw new ArgumentNullException("serialized");

            try
            {
                using (var ms = new EnhancedMemoryStream(Convert.FromBase64String(serialized)))
                {
                    if (ms.ReadInt16() != Magic)
                        throw new FormatException("Bad magic number.");

                    this.IssueDateUtc = new DateTime(ms.ReadInt64(), DateTimeKind.Utc);
                    this.ID = new Guid(ms.ReadBytes(32));
                }
            }
            catch (Exception e)
            {
                throw new ArgumentException("Invalid unique serialized visitor.", "seralized", e);
            }
        }

        /// <summary>
        /// The date/time (UTC) at which the unique visitor was generated.
        /// </summary>
        public DateTime IssueDateUtc { get; private set; }

        /// <summary>
        /// The globall unique ID assigned to this visitor.
        /// </summary>
        public Guid ID { get; private set; }

        /// <summary>
        /// Renders the instance into a string suitable for using as an HTTP cookie.
        /// </summary>
        /// <returns>The cookie string.</returns>
        public override string ToString()
        {
            using (var ms = new EnhancedMemoryStream())
            {
                ms.WriteInt16(Magic);
                ms.WriteInt64(IssueDateUtc.Ticks);
                ms.WriteBytesNoLen(ID.ToByteArray());

                return Convert.ToBase64String(ms.GetBuffer(), 0, (int)ms.Length);
            }
        }

        /// <summary>
        /// Determines whether an object instance equals the current instance.
        /// </summary>
        /// <param name="o">The object to be tested.</param>
        /// <returns><c>true</c> in the objects are equal.</returns>
        public override bool Equals(object o)
        {
            var visitor = o as UniqueVisitor;

            if (visitor == null)
                return false;

            return this.IssueDateUtc == visitor.IssueDateUtc && this.ID == visitor.ID;
        }

        /// <summary>
        /// Computes the hash code for the instance.
        /// </summary>
        /// <returns>The has code.</returns>
        public override int GetHashCode()
        {
            return IssueDateUtc.GetHashCode() ^ ID.GetHashCode();
        }
    }
}
