//-----------------------------------------------------------------------------
// FILE:        WebTransferCache.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:   Copyright (c) 2005-2015 by Jeffrey Lill.  All rights reserved.
// DESCRIPTION: Caches files generated by a website for download or uploaded to a website
//              for the period of time.

using System;
using System.IO;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Threading;
using System.Web;

using LillTek.Common;
using LillTek.Cryptography;

namespace LillTek.Web
{
    /// <summary>
    /// Caches files generated by a website for download or upload to a website
    /// for the period of time.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The <see cref="WebTransferCache" /> class is used by websites for managing folders
    /// containing files that exist for a period of time while being uploaded or downloaded
    /// between the site and a client application.  <see cref="WebTransferCache" /> manages
    /// the life cycle of these file.
    /// </para>
    /// <para>
    /// The <see cref="WebTransferFile" /> class is used manage files while they are being written 
    /// to the cache.  Each file located within a folder specified by the cache and is named by a 
    /// <see cref="Guid" /> and a file extension.  The folder will typically map to a virtual folder 
    /// within the website so that the file will be accessable via standard HTTP methods.
    /// </para>
    /// <para>
    /// Websites should instantiate an instance of this class within their <b>Global.asax.cs</b>,
    /// passing the absolute file path to the folder to hold the cache, the site's absolute 
    /// <see cref="Uri" /> to the cache folder, as well as parameters describing how long items
    /// should be cached.  Then <see cref="Start" /> must be called to initialize the cache.
    /// <see cref="Stop" /> should be called when the web application terminates.
    /// </para>
    /// <para>
    /// This class supports two basic scenarios for writing files to the cache: website generated
    /// files for downloading as well as files uploaded from a client application.
    /// </para>
    /// <para>
    /// Websites may choose to generate files for downloading to implement features like 
    /// Silverlight printing where a PDF (or some other file type) is generated by the server
    /// and then the client launches a new browser instance to download the file so it can
    /// be printed by the browser.  Websites may also choose to generate files that would be
    /// too large to be downloaded via WCF or .NET RIA Services calls.
    /// </para>
    /// <para>
    /// Files generated for downloading should be created by a call to <see cref="GetCommittedFile" />,
    /// passing a specific <see cref="Guid" /> for an existing file or <see cref="Guid.Empty" /> if
    /// a file is to be created with a new ID.  You'll also need to pass the file extension.  
    /// <see cref="GetCommittedFile" /> returns a <see cref="WebTransferFile" /> on which
    /// most applications will call <see cref="WebTransferFile.GetStream" /> to get the stream
    /// where the download data can be written.  Once the data has been written, the application
    /// can pass the value of the <see cref="WebTransferFile" />'s <see cref="WebTransferFile.Uri" /> 
    /// property back to the client so it can gain access to the download via HTTP.
    /// </para>
    /// <para>
    /// The other major use of this class is for managing files being uploaded by the client
    /// to the website via HTTP.  In these situations, the application will typically call 
    /// <see cref="GetUploadFile" /> to create/open an upload file in the cache, passing a
    /// specific <see cref="Guid" /> to open an existing file (typically) or <see cref="Guid.Empty" />
    /// when creating a new file.  This call returns a <see cref="WebTransferFile" /> instance.
    /// </para>
    /// <para>
    /// Files are typically uploaded in chunks (potentially over several HTTP POST requests), 
    /// with each chunk  being appended to the file.  The cache distinguishes between files
    /// still in the process of being uploaded and complete files by appending
    /// <see cref="UploadExtension" /> to the file name while uploading is in progress.
    /// Applications should call the <see cref="WebTransferFile" />'s <see cref="WebTransferFile.Append(byte[])" />
    /// or <see cref="WebTransferFile.Append(long,byte[])" /> method to append the next chunk to the file.
    /// When file transfer is complete, the application should call <see cref="WebTransferFile.Commit()" />
    /// to remove the uploading file extension or <see cref="WebTransferFile.Commit(byte[])" /> to
    /// verify the MD5 signature of the file before completing the upload.
    /// </para>
    /// <para>
    /// This class distributes transfer file across sub folders created within the cache folder
    /// to improve performance in situations where a very large number of files are cached.
    /// The number of subfolders is currently fixed at 100.
    /// </para>
    /// <para>
    /// This class manages the life cycle of the items in the cache periodically on a background
    /// thread.  Files in the process of being uploaded whose last write time is older a specified
    /// maximum will be deleted as will complete files whose age exceeds a maximum.  These values
    /// are passed to the constructor.
    /// </para>
    /// <para>
    /// This class constructs <see cref="Uri" />s for the transfer files it manages.  These are
    /// created by concatenating the site's base <see cref="Uri" /> with the virtual folder path,
    /// the hashed subfolder path and finally, the transfer file name.  The base site <see cref="Uri" />
    /// can be explicitly defined or set to <c>null</c>.  The method will use the base site <see cref="Uri" />
    /// from the current HTTP request when <see cref="SiteUri" /> is <c>null</c>.  This makes for
    /// easy deployment across development, test, and production environments.
    /// </para>
    /// <para>
    /// Files may be explicitly removed from the cache by calling <see cref="DeleteFile(Guid,string)" />
    /// or <see cref="DeleteFile(Uri)" />.  These methods delete the committed files as well as files in 
    /// the process of being uploaded from the cache if they are present.  Well behaved applications 
    /// will delete cached files immediately after they are no longer necessary to keep the total size
    /// of the cache down to a minimum.
    /// </para>
    /// <para><b><u>Configuring for Load Balanced Websites</u></b></para>
    /// <para>
    /// By default, this class does not support load balanced websites due to the fact that the
    /// folder holding the cached files are located within the website's IIS local frile system
    /// folder by default.  It is possible though to configure this for the load balanced scenario.
    /// </para>
    /// <para>
    /// The basic idea is to locate the transfer cache on a shared network folder and then deploy
    /// another website (which can be load balanced as well) dedicated to serving cached files or
    /// configure a virtual folder within the existing site to map to the shared folder.
    /// </para>
    /// <para>
    /// Then you need to configure each website's cache settings such that the <b>SiteUri</b> 
    /// references the dedicated cache website and also set <b>AbsoluteFolder</b> and
    /// <b>VirtualFolder</b> to point to the currect places.
    /// </para>
    /// <para>
    /// You may also want to disable the background file purge thread for some of the
    /// website instances.  This can be done by setting <b>SleepTime</b>=0.  This is
    /// important if you have a large number of web servers to reduce the purge polling
    /// load down on the network share.  Alternatively, you may just bump up the sleep
    /// time on all of web servers and depend on clock skew to average out the purging
    /// performed by the individual servers.
    /// </para>
    /// </remarks>
    public class WebTransferCache
    {
        private const string    NotStartedMsg  = "WebTransferCache has not been started.";
        private const int       SubFolderCount = 100;

        private Thread      bkThread;
        private TimeSpan    sleepTime;

        /// <summary>
        /// The file extension added to files that are in the process of being uploaded: <b>"._uploading"</b>.
        /// </summary>
        public const string UploadExtension = "._uploading";

        /// <summary>
        /// Returns the absolute <see cref="Uri" /> to the site's virtual root Uri or
        /// <c>null</c> if the current HTTP request context is to be used for constructing
        /// transfer file Uris.
        /// </summary>
        public Uri SiteUri { get; private set; }

        /// <summary>
        /// Returns the absolute file system path to the cache's root folder.
        /// </summary>
        public string AbsoluteFolder { get; private set; }

        /// <summary>
        /// The relative path to the cache folder from the application's virtual root.
        /// </summary>
        public string VirtualFolder { get; private set; }

        /// <summary>
        /// Returns the maximum time a complete file will remain in the cache.
        /// </summary>
        public TimeSpan MaxCacheTime { get; private set; }

        /// <summary>
        /// Returns the maximum time a file in the process of being uploaded will remain
        /// in the cache between file writes.
        /// </summary>
        public TimeSpan MaxUploadTime { get; private set; }

        /// <summary>
        /// Returns <c>true</c> if the cache is running.
        /// </summary>
        public bool IsRunning { get; private set; }

        /// <summary>
        /// Available for unit tests to set the background purge timer.
        /// </summary>
        /// <param name="sleepTime">The sleep time.</param>
        internal void SetSleepTime(TimeSpan sleepTime) {

            this.sleepTime = sleepTime;
        }

        /// <summary>
        /// Constructs and instance from explict parameters.
        /// </summary>
        /// <param name="siteUri">The base <see cref="Uri" /> for the website holding the cache folder.</param>
        /// <param name="absoluteFolder">The absolute file system path to the cache's root folder.</param>
        /// <param name="virtualFolder">
        /// The relative path to the cache folder from the application's virtual root.
        /// </param>
        /// <param name="maxCacheTime">The maximum time a complete file will remain in the cache.</param>
        /// <param name="maxUploadTime">
        /// The maximum time a file in the process of being uploaded will remain
        /// in the cache between file writes.
        /// </param>
        public WebTransferCache(Uri siteUri, string absoluteFolder, string virtualFolder, TimeSpan maxCacheTime, TimeSpan maxUploadTime)
        {
            this.IsRunning      = false;
            this.SiteUri        = siteUri;
            this.AbsoluteFolder = absoluteFolder;
            this.VirtualFolder  = virtualFolder;
            this.MaxCacheTime   = maxCacheTime;
            this.MaxUploadTime  = maxUploadTime;
            this.sleepTime      = TimeSpan.FromMinutes(1);
        }

        /// <summary>
        /// Initializes an instance, parsing parameters from configuration settings. 
        /// </summary>
        /// <param name="keyPrefix">The configuration key prefix.</param>
        /// <exception cref="ArgumentException">Thrown if any of the required parameters are missing or invalid.</exception>
        /// <remarks>
        /// <para>
        /// This constructor initializes the cache using parameters obtained from the 
        /// application <see cref="Config" />.  Pass <paramref name="keyPrefix" /> as the
        /// prefix.
        /// </para>
        /// <para>
        /// The configuration parameters are:
        /// </para>
        /// <list type="table">
        ///     <item>
        ///         <term><b>SiteUri</b></term>
        ///         <description>
        ///         The base URI for the site (optional).  If this is not present
        ///         then transfer file URIs will be constructed on the fly based
        ///         on the base URI from the current HTTP request context.
        ///         </description>
        ///     </item>
        ///     <item>
        ///         <term><b>AbsoluteFolder</b></term>
        ///         <description>
        ///         The absolute path to the file system folder where the cache 
        ///         is to be located (required).
        ///         </description>
        ///     </item>
        ///     <item>
        ///         <term>VirtualFolder</term>
        ///         <description>
        ///         The relative path to the cache folder from the application's virtual root.
        ///         </description>
        ///     </item>
        ///     <item>
        ///         <term>MaxCacheTime</term>
        ///         <description>
        ///         The maximum time a file will remain in the cache after being 
        ///         written (defaults to 1 hour).
        ///         </description>
        ///     </item>
        ///     <item>
        ///         <term>MaxUploadTime</term>
        ///         <description>
        ///         The maximum time a file in the process of being uploaded will remain in the cache
        ///         when no additional data has been written (defaults to 5 minutes).
        ///         </description>
        ///     </item>
        ///     <item>
        ///         <term>SleepTime</term>
        ///         <description>
        ///         The time the background thread sleeps between waking up and looking
        ///         for files to purge (defaults to 1 minute).  Set this to <see cref="TimeSpan.Zero" />
        ///         to disable the purge thread.
        ///         </description>
        ///     </item>
        /// </list>
        /// </remarks>
        public WebTransferCache(string keyPrefix)
        {
            var config = new Config(keyPrefix);

            this.IsRunning      = false;
            this.SiteUri        = config.Get("SiteUri", (Uri)null);
            this.AbsoluteFolder = config.Get("AbsoluteFolder");
            this.VirtualFolder  = config.Get("VirtualFolder");
            this.MaxCacheTime   = config.Get("MaxCacheTime", TimeSpan.FromMinutes(60));
            this.MaxUploadTime  = config.Get("MaxUploadTime", TimeSpan.FromMinutes(5));
            this.sleepTime      = config.Get("SleepTime", TimeSpan.FromMinutes(1));

            if (this.AbsoluteFolder == null)
                throw new ArgumentException("WebTransferCache: [AbsoluteFolder] setting is missing.");

            if (this.VirtualFolder == null)
                throw new ArgumentException("WebTransferCache: [VirtualFolder] setting is missing or invalid.");
        }

        /// <summary>
        /// Starts the cache.
        /// </summary>
        /// <exception cref="InvalidOperationException">Thrown if this cache is already running.</exception>
        /// <remarks>
        /// This method creates and initializes the cache folder as necessary and then
        /// starts the background cache life cycle thread.
        /// </remarks>
        public void Start()
        {
            if (IsRunning)
                throw new InvalidOperationException("WebTransferCache is already running.");

            // Create the cache folder and the subfolders if they don't already exist.

            for (int i = 0; i < SubFolderCount; i++)
                Helper.CreateFolderTree(Path.Combine(this.AbsoluteFolder, string.Format("{0:0#}", i)));

            // Start the background thread

            if (sleepTime > TimeSpan.Zero)
            {
                bkThread = new Thread(new ThreadStart(PurgeThread));
                bkThread.Start();
            }

            IsRunning = true;
        }

        /// <summary>
        /// Stops the cache if it's running.
        /// </summary>
        public void Stop()
        {
            if (!IsRunning)
                return;

            if (bkThread != null)
            {
                bkThread.Abort();
                bkThread = null;
            }

            IsRunning = false;
        }

        /// <summary>
        /// Handles the purging of cached files that have exceeded their lifespan.
        /// </summary>
        private void PurgeThread()
        {
            // Wake up once a minute to look for files to be purged.

            while (true)
            {
                Thread.Sleep(sleepTime);

                try
                {
                    // $todo(jeff.lill): 
                    //
                    // .NET 4.0 will include new methods that will let us avoid 
                    // making calls to get the file times.

                    DateTime uploadLimitUtc = DateTime.UtcNow - this.MaxUploadTime;
                    DateTime cacheLimitUtc = DateTime.UtcNow - this.MaxCacheTime;

                    foreach (var filePath in Helper.GetFilesByPattern(Path.Combine(this.AbsoluteFolder, "*.*"), SearchOption.AllDirectories))
                    {
                        try
                        {
                            var fileInfo = new FileInfo(filePath);

                            if (filePath.EndsWith(UploadExtension))
                            {
                                if (fileInfo.LastWriteTimeUtc < uploadLimitUtc)
                                    File.Delete(filePath);
                            }
                            else
                            {
                                if (fileInfo.LastWriteTimeUtc < cacheLimitUtc)
                                    File.Delete(filePath);
                            }
                        }
                        catch (IOException)
                        {
                            // Ignore these
                        }
                    }
                }
                catch (ThreadAbortException)
                {
                    return;     // The thread is being aborted so just exit.
                }
                catch (Exception e)
                {
                    SysLog.LogException(e);
                }
            }
        }

        /// <summary>
        /// Returns the subfolder name a file with the specified ID will be hashed to.
        /// </summary>
        /// <param name="id">The file <see cref="Guid" />.</param>
        /// <returns>The subfolder name.</returns>
        internal string HashIDToSubFolder(Guid id)
        {
            return string.Format("{0:0#}/", Helper.HashToIndex(SubFolderCount, id.GetHashCode()));
        }

        /// <summary>
        /// Gets or creates a file that the website can use for generating a
        /// cached file that can be downloaded from or uploaded to the site.
        /// </summary>
        /// <param name="id">
        /// The existing file <see cref="Guid" /> or <see cref="Guid.Empty" />
        /// to create a new file.
        /// </param>
        /// <param name="fileExtension">The file extension including the leading period.</param>
        /// <param name="isUploading">Pass <c>true</c> for an upload file, <c>false</c> for a committed file.</param>
        /// <returns>The <see cref="WebTransferFile" /> instance.</returns>
        /// <exception cref="FileNotFoundException">Thrown if the file requested does not exist.</exception>
        /// <exception cref="InvalidOperationException">
        /// Thrown if the cache has not been started or <see cref="SiteUri" /> is
        /// <c>null</c> and the call is not being made while processing an HTTP request.
        /// </exception>
        /// <remarks>
        /// <note>
        /// This method is designed primarily to be called within the context of an ASP.NET
        /// web request being processed although this will work if <see cref="SiteUri" /> is
        /// initialized to a non-<c>null</c> value.
        /// </note>
        /// </remarks>
        private WebTransferFile GetFile(Guid id, string fileExtension, bool isUploading)
        {
            bool        create = false;
            string      subFolder;
            Uri         siteUri;
            Uri         requestUri;

            if (!IsRunning)
                throw new InvalidOperationException(NotStartedMsg);

            if (id == Guid.Empty)
            {
                id     = Guid.NewGuid();
                create = true;
            }

            if (this.SiteUri != null)
                siteUri = this.SiteUri;
            else
            {
                if (HttpContext.Current == null)
                    throw new InvalidOperationException("WebTransfer.GetFile: SiteUri must be non-null or method must be called within the context of a HTTP request.");

                requestUri = HttpContext.Current.Request.Url;
                siteUri    = new Uri(string.Format("{0}://{1}:{2}/", requestUri.Scheme, requestUri.Host, requestUri.Port));
            }

            subFolder = HashIDToSubFolder(id);

            return new WebTransferFile(id, Path.Combine(this.AbsoluteFolder, subFolder), new Uri(siteUri, this.VirtualFolder + "/" + subFolder), fileExtension, create, isUploading);
        }

        /// <summary>
        /// Gets or creates a file that the website can use for generating a
        /// cached file that can has been committed to the cache.
        /// </summary>
        /// <param name="id">
        /// The existing file <see cref="Guid" /> or <see cref="Guid.Empty" />
        /// to create a new file.
        /// </param>
        /// <param name="fileExtension">The file extension including the leading period.</param>
        /// <returns>The <see cref="WebTransferFile" /> instance.</returns>
        /// <exception cref="FileNotFoundException">Thrown if the file requested does not exist.</exception>
        /// <exception cref="InvalidOperationException">Thrown if the cache has not been started.</exception>
        public WebTransferFile GetCommittedFile(Guid id, string fileExtension)
        {
            return GetFile(id, fileExtension, false);
        }

        /// <summary>
        /// Gets or creates a file that the be used for uploading a file 
        /// file to be cached on the site.
        /// </summary>
        /// <param name="id">
        /// The existing file <see cref="Guid" /> or <see cref="Guid.Empty" />
        /// to create a new file.
        /// </param>
        /// <param name="fileExtension">The file extension including the leading period.</param>
        /// <returns>The <see cref="WebTransferFile" /> instance.</returns>
        /// <exception cref="FileNotFoundException">Thrown if the file requested does not exist.</exception>
        /// <exception cref="InvalidOperationException">Thrown if the cache has not been started.</exception>
        public WebTransferFile GetUploadFile(Guid id, string fileExtension)
        {
            return GetFile(id, fileExtension, true);
        }

        /// <summary>
        /// Removes the specified file from the cache if it is present. 
        /// </summary>
        /// <param name="id">The file <see cref="Guid" />.</param>
        /// <param name="fileExtension">The file extension including the leading period.</param>
        /// <exception cref="InvalidOperationException">Thrown if the cache has not been started.</exception>
        /// <remarks>
        /// <para>
        /// This method deletes the uploaded file as well as a file in the process of being uploaded from the
        /// cache if they are present.  Well behaved applications will delete cached files immediately after
        /// they are no longer necessary to keep the total size of the cache down to a minimum.
        /// </para>
        /// <note>
        /// This method does not throw an exception if the specified file does not exist.
        /// </note>
        /// </remarks>
        public void DeleteFile(Guid id, string fileExtension)
        {
            string      subFolder;
            string      fileName;

            if (!IsRunning)
                throw new InvalidOperationException(NotStartedMsg);

            subFolder = HashIDToSubFolder(id);
            fileName = Path.Combine(Path.Combine(this.AbsoluteFolder, subFolder), id.ToString("D") + fileExtension);

            try
            {
                Helper.DeleteFile(fileName);
                Helper.DeleteFile(fileName + UploadExtension);
            }
            catch (IOException)
            {

                // Ignore these
            }
        }

        /// <summary>
        /// Removes the specified file from the cache if it is present. 
        /// </summary>
        /// <param name="uri">The file <see cref="Uri" />.</param>
        /// <exception cref="InvalidOperationException">Thrown if the cache has not been started.</exception>
        /// <remarks>
        /// <para>
        /// This method deletes the uploaded file as well as a file in the process of being uploaded from the
        /// cache if they are present.  Well behaved applications will delete cached files immediately after
        /// they are no longer necessary to keep the total size of the cache down to a minimum.
        /// </para>
        /// <note>
        /// This method does not throw an exception if the specified file does not exist or if the
        /// <paramref name="uri" /> does not map to the cache folder.
        /// </note>
        /// </remarks>
        public void DeleteFile(Uri uri)
        {
            // Try to extract the GUID and file extension from the URI and then
            // call the other delete method.  We're going to ignore malformed
            // URIs.

            // Assume that the characters up to the first period (.) in the last
            // segment of the URI form the GUID and the remaining characters,
            // the file extension.

            string      segment;
            string      idString;
            Guid        id;
            string      fileExtension;
            int         pos;

            if (uri.Segments.Length == 0)
                return;     // Malformed cache file uri

            segment = uri.Segments[uri.Segments.Length - 1];

            pos = segment.IndexOf('.');
            if (pos == -1)
                return;     // Malformed cache file uri

            idString      = segment.Substring(0, pos);
            fileExtension = segment.Substring(pos);

            try
            {
                id = new Guid(idString);
            }
            catch (Exception e)
            {
                SysLog.LogException(e);
                return;     // Malformed cache file uri
            }

            DeleteFile(id, fileExtension);
        }

        /// <summary>
        /// Encrypts the committed file using the specified symmetric encryption key.
        /// </summary>
        /// <param name="key">The symmetric encryption key.</param>
        /// <param name="id">The file <see cref="Guid" />.</param>
        /// <param name="fileExtension">The file extension including the leading period.</param>
        /// <exception cref="InvalidOperationException">Thrown if the cache has not been started.</exception>
        /// <exception cref="InvalidOperationException">Thrown if file does not exist or has not been committed.</exception>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="key" /> is <c>null</c>.</exception>
        /// <exception cref="IOException">Thrown if there's a problem reading or writing file data.</exception>
        /// <exception cref="CryptographicException">Thrown if there's any encryption failure.</exception>
        public void EncryptFile(SymmetricKey key, Guid id, string fileExtension)
        {
            if (key == null)
                throw new ArgumentNullException("key");

            GetFile(id, fileExtension, false).Encrypt(key);
        }

        /// <summary>
        /// Streams a commited file back to a client on the ambient HTTP request, optionally decrypting it first.
        /// </summary>
        /// <param name="key">Pass as the encryption key if the file is to be decrypted before delivery or <c>null</c> if the file is to be delivered as is.</param>
        /// <param name="id">The file <see cref="Guid" />.</param>
        /// <param name="fileName">The name of the file to be used when setting the response's <b>Content-Disposition</b> header or just the file extension (including the leading period).</param>
        /// <exception cref="InvalidOperationException">Thrown if the method is not called within the processing context of a HTTP request.</exception>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="fileName" /> is <c>null</c>.</exception>
        public void StreamFile(SymmetricKey key, Guid id, string fileName)
        {
            var context = HttpContext.Current;

            if (context == null)
                throw new InvalidOperationException(WebHelper.NoHttpContextMsg);

            var response = context.Response;

            if (fileName == null)
                throw new ArgumentNullException("fileName");

            var fileExtension = Path.GetExtension(fileName);

            if (string.IsNullOrWhiteSpace(fileExtension))
                fileExtension = ".";

            if (!string.IsNullOrWhiteSpace(fileName))
                WebHelper.SetResponseContentDisposition(fileName);

            var mimeType = WebHelper.GetMimeMapping(fileName);

            if (mimeType != null)
                response.ContentType = mimeType;

            // Make sure the file actually exists.

            var cachedFile = GetFile(id, fileExtension, false);
            var fileInfo = new FileInfo(cachedFile.Path);

            if (!fileInfo.Exists)
            {
                response.StatusCode = 404;
                response.StatusDescription = "Not Found";

                response.End();
                return;
            }

            // If there's no key, we can simply let IIS stream the file directly.

            if (key == null)
            {
                response.StatusCode = 200;
                response.StatusDescription = "OK";

                response.WriteFile(cachedFile.Path);
                response.End();
                return;
            }

            // We need to decrypt and stream the file.

            using (var encryptedStream = new FileStream(cachedFile.Path, FileMode.Open, FileAccess.Read))
            {
                using (var decryptor = new StreamDecryptor(key))
                {
                    decryptor.Decrypt(encryptedStream, response.OutputStream);
                }
            }

            response.End();
        }
    }
}
