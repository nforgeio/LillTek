//-----------------------------------------------------------------------------
// FILE:        DnsMessage.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:   Copyright (c) 2005-2015 by Jeffrey Lill.  All rights reserved.
// DESCRIPTION: Implements a base DNS message (the base class for the DnsRequest
//              DnsResponse classes).

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

using LillTek.Common;

namespace LillTek.Net.Sockets
{
    /// <summary>
    /// Implements the base DNS message behaviors.  This class is the
    /// base class for both the <see cref="DnsRequest" /> and <see cref="DnsResponse" />
    /// classes.
    /// </summary>
    public class DnsMessage
    {
        /// <summary>
        /// The largest possible DNS packet.
        /// </summary>
        public const int PacketSize = 512;

        // Private instance variables

        private ushort                      qid;                // Query ID generated by the caller
        private DnsFlag                     flags;              // Query flags
        private string                      qname;              // Domain name being queried
        private DnsQType                    qtype;              // Query type
        private DnsQClass                   qclass;             // Query class
        private List<DnsRR>                 answers;            // Answer RRs (or null)
        private List<DnsRR>                 authorities;        // Authority RRs (or null)
        private List<DnsRR>                 additional;         // Additional RRs (or null)
        private Dictionary<string, int>     namePtrs;           // Set of existing name compression pointers

        /// <summary>
        /// This constructor initializes the message fields to default values.
        /// </summary>
        public DnsMessage()
        {
            this.qid         = 0;
            this.flags       = 0;
            this.qname       = null;
            this.qtype       = DnsQType.NULL;
            this.qclass      = DnsQClass.IN;
            this.answers     = null;
            this.authorities = null;
            this.additional  = null;
            this.namePtrs    = null;
        }

        /// <summary>
        /// Shallow copies the data members from the source message passed
        /// to this instance.
        /// </summary>
        /// <param name="source">The source message.</param>
        protected void CopyFrom(DnsMessage source)
        {
            this.qid         = source.qid;
            this.flags       = source.flags;
            this.qname       = source.qname;
            this.qtype       = source.qtype;
            this.qclass      = source.qclass;
            this.answers     = source.answers;
            this.authorities = source.authorities;
            this.additional  = source.additional;
        }

        /// <value>
        /// Specifies the query ID generated by the client.
        /// </value>
        public ushort QID
        {
            get { return this.qid; }
            set { this.qid = value; }
        }

        /// <value>
        /// Specifies the query opcode.
        /// </value>
        public DnsOpcode Opcode
        {
            get { return (DnsOpcode)((int)(this.flags & DnsFlag.OPCODE_MASK) >> (int)DnsFlag.OPCODE_SHIFT); }

            set
            {
                this.flags &= ~DnsFlag.OPCODE_MASK;
                this.flags |= (DnsFlag)((int)value << (int)DnsFlag.OPCODE_SHIFT);
            }
        }

        /// <value>
        /// Specifies the name being queried.
        /// </value>
        public string QName
        {
            get { return this.qname; }
            set { this.qname = value; }
        }

        /// <value>
        /// Specifies query type.
        /// </value>
        public DnsQType QType
        {
            get { return this.qtype; }
            set { this.qtype = value; }
        }

        /// <value>
        /// Specifies the query class.
        /// </value>
        public DnsQClass QClass
        {
            get { return this.qclass; }
            set { this.qclass = value; }
        }

        /// <summary>
        /// Specifies the message flags.
        /// </summary>
        public DnsFlag Flags
        {
            get { return this.flags; }
            set { this.flags = value; }
        }

        /// <summary>
        /// Specifies the return code.
        /// </summary>
        public DnsFlag RCode
        {
            get { return this.flags & DnsFlag.RCODE_MASK; }

            set
            {
                this.flags &= ~DnsFlag.RCODE_MASK;
                this.flags |= (value & DnsFlag.RCODE_MASK);
            }
        }

        /// <summary>
        /// Returns the collection of answer resource records.
        /// </summary>
        public List<DnsRR> Answers
        {
            get
            {
                if (answers == null)
                    answers = new List<DnsRR>();

                return answers;
            }
        }

        /// <summary>
        /// Returns the collection of authority resource records.
        /// </summary>
        public List<DnsRR> Authorities
        {
            get
            {
                if (authorities == null)
                    authorities = new List<DnsRR>();

                return authorities;
            }
        }

        /// <summary>
        /// Returns the collection of additional resource records.
        /// </summary>
        public List<DnsRR> Additional
        {
            get
            {
                if (additional == null)
                    additional = new List<DnsRR>();

                return additional;
            }
        }

        /// <summary>
        /// This method parses the raw DNS message packet passed and initializes 
        /// the message properties.
        /// </summary>
        /// <param name="packet">The raw DNS packet received.</param>
        /// <param name="cbPacket">Number of bytes in that packet.</param>
        /// <returns>True on success.</returns>
        public bool ParsePacket(byte[] packet, int cbPacket)
        {
            uint    qdCount;
            uint    anCount;
            uint    nsCount;
            uint    arCount;
            int     pos;

            // Read the message header

            pos        = 0;
            this.qid   = (ushort)Helper.ReadInt16(packet, ref pos); if (pos > cbPacket) return false;
            this.flags = (DnsFlag)Helper.ReadInt16(packet, ref pos); if (pos > cbPacket) return false;
            qdCount    = (ushort)Helper.ReadInt16(packet, ref pos); if (pos > cbPacket) return false;
            anCount    = (ushort)Helper.ReadInt16(packet, ref pos); if (pos > cbPacket) return false;
            nsCount    = (ushort)Helper.ReadInt16(packet, ref pos); if (pos > cbPacket) return false;
            arCount    = (ushort)Helper.ReadInt16(packet, ref pos); if (pos > cbPacket) return false;

            Assertion.Test(pos == 12);

            // Check for unsupported packets

            if ((this.flags & DnsFlag.TC) != 0)     // truncation bit is set
                return false;

            if (this.Opcode != DnsOpcode.QUERY)     // only accept standard queries
                return false;

            if (qdCount != 1)                       // only supporting one question
                return false;

            // Parse the question

            if (!ReadName(packet, ref pos, out this.qname))
                return false;

            if (pos > cbPacket)
                return false;

            this.qtype  = (DnsQType)Helper.ReadInt16(packet, ref pos); if (pos > cbPacket) return false;
            this.qclass = (DnsQClass)Helper.ReadInt16(packet, ref pos); if (pos > cbPacket) return false;

            // We're only going to accept Internet queries

            if (this.qclass != DnsQClass.IN)
                return false;

            // Parse the answer records

            for (int i = 0; i < anCount; i++)
            {
                var rr  = DnsRR.Parse(this, packet, ref pos);

                if (rr == null || pos > cbPacket)
                    return false;

                this.Answers.Add(rr);
            }

            // Parse the authority records

            for (int i = 0; i < nsCount; i++)
            {
                var rr = DnsRR.Parse(this, packet, ref pos);

                if (rr == null || pos > cbPacket)
                    return false;

                this.Authorities.Add(rr);
            }

            // Parse the additional records

            for (int i = 0; i < arCount; i++)
            {
                var rr = DnsRR.Parse(this, packet, ref pos);

                if (rr == null || pos > cbPacket)
                    return false;

                this.Additional.Add(rr);
            }

            // $todo(jeff.lill): 
            //
            // Delete this once we've figured out why the DNS server
            // sometimes get requests with NULL QNAME properties.

            if (this.QName == null)
            {
                var packetBytes     = Helper.Extract(packet, cbPacket);
                var hexDump         = Helper.HexDump(packetBytes, 16, HexDumpOption.ShowAll);
                var diagnostics     = GetTraceDetails(IPAddress.Any);
                var extendedLogInfo = new StringSysLogEntryExtension(diagnostics + "\r\n\r\nPacket:\r\n\r\n" + hexDump);

                SysLog.LogWarning(extendedLogInfo, "DNS Packet with QNAME=NULL");
            }

            return true;
        }

        /// <summary>
        /// Serializes the message into a byte array formatted as a
        /// DNS protocol response packet as defined by RFC 1035.
        /// </summary>
        /// <param name="cb">Returns as the size of the formatted packet in bytes.</param>
        /// <returns>The <see cref="PacketSize" /> byte buffer with the formatted packet.</returns>
        public byte[] FormatPacket(out int cb)
        {
            var     packet = new byte[PacketSize];
            int     pos;

            try
            {
                // Initialize the name compression pointer table.

                namePtrs = new Dictionary<string, int>();

                // Write the message header

                pos = 0;

                Helper.WriteInt16(packet, ref pos, qid);
                Helper.WriteInt16(packet, ref pos, (int)flags);
                Helper.WriteInt16(packet, ref pos, 1);     // One question
                Helper.WriteInt16(packet, ref pos, (int)(answers == null ? 0 : answers.Count));
                Helper.WriteInt16(packet, ref pos, (int)(authorities == null ? 0 : authorities.Count));
                Helper.WriteInt16(packet, ref pos, (int)(additional == null ? 0 : additional.Count));

                Assertion.Test(pos == 12);

                // Write the question

                WriteName(packet, ref pos, qname);
                Helper.WriteInt16(packet, ref pos, (int)qtype);
                Helper.WriteInt16(packet, ref pos, (int)qclass);

                // Write the resource records

                if (answers != null)
                    for (int i = 0; i < answers.Count; i++)
                        ((DnsRR)answers[i]).Write(this, packet, ref pos);

                if (authorities != null)
                    for (int i = 0; i < authorities.Count; i++)
                        ((DnsRR)authorities[i]).Write(this, packet, ref pos);

                if (additional != null)
                    for (int i = 0; i < additional.Count; i++)
                        ((DnsRR)additional[i]).Write(this, packet, ref pos);
            }
            catch (IndexOutOfRangeException)
            {
                // $hack(jeff.lill): 
                //
                // OK I know, using an exception to catch overflow
                // situations like this is a really bad idea but 
                // give me a break, this is old code and I don't
                // want to mess with it right now.

                // Set the truncation bit in the response

                flags |= DnsFlag.TC;
                pos = 2;
                Helper.WriteInt16(packet, ref pos, (int)flags);
                pos = PacketSize;
            }
            finally
            {
                namePtrs = null;
            }

            cb = pos;
            return packet;
        }

        /// <summary>
        /// Used internally by unit tests to aid in testing domain name compression.
        /// </summary>
        /// <param name="namePtrs"></param>
        internal void SetNamePtrs(Dictionary<string,int> namePtrs) 
        {
            this.namePtrs = namePtrs;
        }

        /// <summary>
        /// Parses a domain name from the packet beginning that the
        /// offset passed.  If the name is compressed via the DNS name compression
        /// scheme, then this method will decompress it.
        /// </summary>
        /// <param name="packet">The request packet.</param>
        /// <param name="offset">
        /// Byte offset of the first byte of the name.  This will return set
        /// to the offset of the first byte after the name in the packet.
        /// </param>
        /// <param name="name">The parsed string will be copied here.</param>
        /// <returns>True on success.</returns>
        public bool ReadName(byte[] packet, ref int offset, out string name)
        {
            var     sb       = new StringBuilder(PacketSize);
            var     encoder  = Helper.AnsiEncoding;
            int     len      = packet.Length;
            int     off      = offset;
            int     afterPtr = -1;
            int     cPtrs    = 0; ;
            byte    cb;

            name = string.Empty;

            // Parse the name

            while (true)
            {
                if (off >= len)
                    return false;

                cb = packet[off++];
                if (cb == 0)
                {
                    sb.Append('.');                     // Add the root domain
                    break;
                }

                if ((cb & 0xC0) == 0xC0)
                {
                    // We have a label pointer

                    cPtrs++;
                    if (cPtrs > 5)                      // Don't allow pointers to nest
                        return false;                   // more than 5 levels

                    if (afterPtr == -1)
                        afterPtr = off + 1;             // Save the offset of the first byte
                                                        // after the pointer (unless we've already 
                                                        // followed a pointer).

                    off = ((cb & 0x3F) << 8) + packet[off];
                    continue;
                }
                else if ((cb & 0xC0) != 0)
                    return false;                       // Invalid pointer bits

                if (sb.Length > 0)
                    sb.AppendFormat(".{0}", encoder.GetString(packet, off, cb));
                else
                    sb.Append(encoder.GetString(packet, off, cb));

                off += cb;
            }

            offset = afterPtr != -1 ? afterPtr : off;
            name = sb.ToString();
            return true;
        }

        private sealed class DomainPtr
        {
            public string   Domain;
            public int      Offset;

            public DomainPtr(string domain, int offset)
            {
                this.Domain = domain;
                this.Offset = offset;
            }
        }

        /// <summary>
        /// Writes the domain name to the packet beginning at the offset passed.  
        /// The name will be written in label format using message compression
        /// as described in RFC 1035 section 4.1.4.
        /// </summary>
        /// <param name="packet">The output packet buffer.</param>
        /// <param name="offset">
        /// The offset in the packet where the name will be written.
        /// This parameter will return set to the offset of the first
        /// byte after the written name.
        /// </param>
        /// <param name="name">The domain name to write.</param>
        public void WriteName(byte[] packet, ref int offset, string name)
        {
            Encoding        encoder = Helper.AnsiEncoding;
            List<DomainPtr> ptrs;
            int             pos;
            int             ptrOffset;
            string          label;
            byte[]          bytes;

            if (namePtrs == null)
                throw new InvalidOperationException("[WriteName] can only be called within the context of a [FormatPacket] call.");

            if (!name.EndsWith("."))
                throw new ArgumentException("Domain names must end with [.]", "name");

            name = name.Substring(0, name.Length - 1);     // $todo(jeff.lill): 

            // This could be a bit of a performance
            // problem and is really unnecessary.  At some
            // point I should modify the code below to be
            // able to handle the terminating root domain
            // dot in-line.

            if (name.Length == 0)
            {
                packet[offset++] = 0;
                return;
            }

            ptrs = new List<DomainPtr>();

            while (true)
            {
                ptrs.Add(new DomainPtr(name, offset));

                pos = name.IndexOf('.');
                if (pos == -1)
                    label = name;
                else
                    label = name.Substring(0, pos);

                if (label.Length >= 64)
                    throw new ArgumentException("Domain label is longer than 63 characters.");
                else if (label.Length == 0)
                    throw new ArgumentException("Zero length domain label not allowed except for the terminating root.");

                if (namePtrs.TryGetValue(name, out ptrOffset))
                {
                    // The remaining name already exists in the packet so
                    // just write a pointer to that instance.

                    packet[offset++] = (byte)(0xC0 | (ptrOffset >> 8));
                    packet[offset++] = (byte)ptrOffset;
                    return;
                }

                packet[offset++] = (byte)label.Length;
                bytes            = encoder.GetBytes(label);
                Array.Copy(bytes, 0, packet, offset, bytes.Length);
                offset += bytes.Length;

                if (pos == -1)
                    break;

                name = name.Substring(pos + 1);
            }

            packet[offset++] = 0;   // Indicates the terminating root domain

            // Add pointers to all of the domains just written
            // to the global pointer table.

            for (int i = 0; i < ptrs.Count; i++)
                namePtrs.Add(ptrs[i].Domain, ptrs[i].Offset);
        }

        /// <summary>
        /// Compares the message's query type and qname to the parameters passed.
        /// </summary>
        /// <param name="qtype">The query type to be matched.</param>
        /// <param name="qname">The query name to be matched.</param>
        /// <returns><c>true</c> if both parameters match the values stored in the message.</returns>
        public bool Match(DnsQType qtype, string qname)
        {
            return this.QType == qtype && String.Compare(this.QName, qname, true) == 0;
        }

        /// <summary>
        /// Compares the query type and qname of this message to the one
        /// passed.
        /// </summary>
        /// <param name="message">The message to be compared.</param>
        /// <returns><c>true</c> if the query type and qnames match.</returns>
        public bool Match(DnsMessage message)
        {
            return this.QType == message.QType && String.Compare(this.QName, message.QName, true) == 0;
        }

        /// <summary>
        /// Converts an RCODE value encoded in message flag bits into a human readable string.
        /// </summary>
        /// <param name="flags">The message flags.</param>
        /// <returns>The output string.</returns>
        private string RCODE2String(DnsFlag flags)
        {
            switch (flags & DnsFlag.RCODE_MASK)
            {
                case DnsFlag.RCODE_OK:      return "RCODE_OK";
                case DnsFlag.RCODE_FORMAT:  return "RCODE_FORMAT";
                case DnsFlag.RCODE_SERVER:  return "RCODE_SERVER";
                case DnsFlag.RCODE_NAME:    return "RCODE_NAME";
                case DnsFlag.RCODE_NOTIMPL: return "RCODE_NOTIMPL";
                case DnsFlag.RCODE_REFUSED: return "RCODE_REFUSED";
                default:                    return string.Format("RCODE({0})", (int)(flags & DnsFlag.RCODE_MASK));
            }
        }

        /// <summary>
        /// Returns details of the message contents in a format suitable for
        /// writing as a trace output.
        /// </summary>
        /// <param name="addr">
        /// IP address of the name server the message is being sent to or 
        /// was received from.
        /// </param>
        public string GetTraceDetails(IPAddress addr)
        {
            StringBuilder   sb;
            int             cAnswers;
            int             cAuthorities;
            int             cAdditional;
            bool            isResponse = (flags & DnsFlag.QR) != 0;
            string          rcode      = RCODE2String(flags);
            string          sFlags;

            // Count the resource records

            cAnswers     = answers == null ? 0 : answers.Count;
            cAuthorities = authorities == null ? 0 : authorities.Count;
            cAdditional  = additional == null ? 0 : additional.Count;

            if (isResponse)
                sFlags = rcode + " ";
            else
                sFlags = string.Empty;

            if ((flags & DnsFlag.AA) != 0)
                sFlags += "AA ";

            if ((flags & DnsFlag.RA) != 0)
                sFlags += "RA ";

            if ((flags & DnsFlag.RD) != 0)
                sFlags += "RD ";

            if ((flags & DnsFlag.TC) != 0)
                sFlags += "TC ";

            sb = new StringBuilder();
            sb.AppendFormat("Type:  {0}\r\n", isResponse ? "Response" : "Query");
            sb.AppendFormat("QID:   {0:05}\r\n", qid);
            sb.AppendFormat("IP:    {0}\r\n", addr);
            sb.AppendFormat("QName: {0}\r\n", qname ?? "NULL");
            sb.AppendFormat("Flags: {0}\r\n", sFlags);

            if (cAnswers > 0)
            {
                sb.AppendLine("----------");
                sb.AppendFormat("ANSWERS ({0}):\r\n", answers == null ? 0 : answers.Count);
                for (int i = 0; i < cAnswers; i++)
                    answers[i].WriteTrace(sb);
            }

            if (cAuthorities > 0)
            {
                sb.AppendLine("----------");
                sb.AppendFormat("AUTHORITIES ({0}):\r\n", authorities == null ? 0 : authorities.Count);
                for (int i = 0; i < cAuthorities; i++)
                    authorities[i].WriteTrace(sb);
            }

            if (cAdditional > 0)
            {
                sb.AppendLine("----------");
                sb.AppendFormat("ADDITIONAL ({0}):\r\n", additional == null ? 0 : additional.Count);
                for (int i = 0; i < cAdditional; i++)
                    additional[i].WriteTrace(sb);
            }

            return sb.ToString();
        }

        /// <summary>
        /// Writes information about then DNS message to the <see cref="NetTrace" />.
        /// </summary>
        /// <param name="component">
        /// The name of the component issuing this call (this will be
        /// included on the trace event'as summary line.
        /// </param>
        /// <param name="detail">The trace detail level.</param>
        /// <param name="addr">
        /// IP address of the name server the message is being sent to or 
        /// was received from.
        /// </param>
        /// <param name="eventTitle">
        /// The trace event title prefix or <c>null</c> to display a default value.
        /// </param>
        [Conditional("TRACE")]
        public void Trace(string component, int detail, IPAddress addr, string eventTitle)
        {
            StringBuilder   sb;
            string          evt;
            string          summary;
            int             cAnswers;
            int             cAuthorities;
            int             cAdditional;
            bool            isResponse = (flags & DnsFlag.QR) != 0;
            string          rcode      = RCODE2String(flags); ;

            // Count the resource records

            cAnswers     = answers == null ? 0 : answers.Count;
            cAuthorities = authorities == null ? 0 : authorities.Count;
            cAdditional  = additional == null ? 0 : additional.Count;

            // Built the event string

            if (eventTitle == null)
                eventTitle = string.Empty;
            else if (!eventTitle.EndsWith(" "))
                eventTitle += " ";

            evt = string.Format("{0}DNS {1} [{2}: {3}]", eventTitle, isResponse ? "Response" : "Query", qtype.ToString(), qname);

            // Build the summary string

            sb = new StringBuilder();
            sb.AppendFormat("{0}: qid={1:05} ip={2}", component, qid, addr);

            if (isResponse)
                sb.AppendFormat(" flags=[ {0}", rcode);
            else
                sb.Append(" flags=[");

            if ((flags & DnsFlag.AA) != 0)
                sb.Append(" AA");

            if ((flags & DnsFlag.RA) != 0)
                sb.Append(" RA");

            if ((flags & DnsFlag.RD) != 0)
                sb.Append(" RD");

            if ((flags & DnsFlag.TC) != 0)
                sb.Append(" TC");

            sb.Append(" ]");

            if ((flags & DnsFlag.QR) != 0)
                sb.AppendFormat(" answers={0} auths={1} additional={2}", cAnswers, cAuthorities, cAdditional);

            summary = sb.ToString();

            // Write the trace event

            NetTrace.Write(component, detail, evt, summary, GetTraceDetails(addr));
        }
    }
}
