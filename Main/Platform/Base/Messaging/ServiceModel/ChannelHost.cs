//-----------------------------------------------------------------------------
// FILE:        ChannelHost.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:   Copyright (c) 2005-2015 by Jeffrey Lill.  All rights reserved.
// DESCRIPTION: Manages global application state required by LillTek WCF channels.

using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Reflection;
using System.Collections.Generic;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.ServiceModel.Description;
using System.Web;
using System.Web.Hosting;

using LillTek.Common;
using LillTek.Messaging;

namespace LillTek.ServiceModel
{
    /// <summary>
    /// Manages global application state required by LillTek WCF channels.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The LillTek WCF channels rely on the presence of a single
    /// global <see cref="LeafRouter" /> instance within the process to manage the
    /// sending and receiving of messages.  The <see cref="Start()" />, <see cref="Start(Assembly)" />,
    /// or <see cref="StartWeb" /> methods can be used to explicitly start the router (and incidentially
    /// specify the location of the application configuration settings).  <see cref="Router" />
    /// will return the global <see cref="MsgRouter" /> if there is one, and <see cref="Stop" />
    /// will gracefully stop the global message router, if one exists and is started.
    /// </para>
    /// <para>
    /// Native LillTek Platform applications should continue to call the <see cref="Helper" />
    /// class' <see cref="Helper.InitializeApp" /> and <see cref="Helper.InitializeWebApp" /> methods during application startup
    /// and should explicitly instantiate and start a <see cref="LeafRouter" /> instance.  This
    /// class is designed to make it easy for non-LillTek Platform applications to take advantage
    /// of the LillTek WCF channel implementation.
    /// </para>
    /// <para><b><u>Best Practices: Normal Services and Applications</u></b></para>
    /// <para>
    /// Non-native applications should call <see cref="Start(Assembly)" /> early in the application
    /// initialization process, passing the <see cref="Assembly" /> reference to the application's
    /// entry assembly.  This can be obtained by calling <see cref="Assembly.GetEntryAssembly" /> or
    /// <see cref="Assembly.GetExecutingAssembly()" /> from code running within the entry assembly.
    /// The <b>Start()</b> method uses this assembly to determine the name of the application's
    /// LillTek configuration file and also to create and start a <see cref="LeafRouter" />, using
    /// settings loaded from the configuration.
    /// </para>
    /// <para>
    /// Configuration file names are generated by replacing the entry assembly's <b>.exe</b> or <b>.dll</b>
    /// file extension with <b>.ini</b>.  So, if the your entry assembly is named <b>MyApplication.exe</b>,
    /// the <b>Start()</b> method will look for a configuration file named <b>MyApplication.ini</b>.
    /// </para>
    /// <para>
    /// The message router created will be initialized using settings from the <b>LillTek.MsgRouter</b>
    /// section of the configuration file.  See <see cref="LeafRouter"/>.<see cref="LeafRouter.Start()" /> 
    /// for a description of the possible router configuration settings.  Note that router configuration 
    /// settings can also be loaded from an standard .NET configuration file.  See <see cref="Config" />
    /// for more ionformation on how configuration settings work.
    /// </para>
    /// <para>
    /// Applications should call <see cref="Stop" /> just before they exit.  This will gracefully
    /// stop the message router is one is present and is started, proactively notifying all other
    /// nodes in the network that the application's endpoints are no longer present.
    /// </para>
    /// <para><b><u>Best Practices: Web Applications</u></b></para>
    /// <para>
    /// The LillTek WCF channels can also be used within ASP.NET applications.
    /// Initialization works a bit differently for web applications.  Basically, you need to
    /// creare the <b>Global.asax</b> file within your application and implement <b>Application_Start()</b>
    /// and <b>Application_End()</b> event handlers.
    /// </para>
    /// <para>
    /// Within the <b>Application_Start()</b> handler, you should call <see cref="StartWeb" /> to
    /// create and start a <see cref="LeafRouter" /> and incidentially specifying the location
    /// of the LillTek application configuration file.  This file has the fixed name <b>Web.ini</b>
    /// and is located in the root directory of the web application.  Note that router configuration 
    /// settings can also be loaded from an standard .NET configuration file.  See <see cref="Config" />
    /// for more ionformation on how configuration settings work.
    /// </para>
    /// <para>
    /// To complete the implementation, call <see cref="Stop" /> within the <b>Application_End()</b>
    /// event handler.
    /// </para>
    /// <para><b><u>Automatic LillTek WCF Channel Behavior</u></b></para>
    /// <para>
    /// LillTek WCF channels will also attempt to instantiate a <see cref="LeafRouter" />
    /// instance if one is not already running when a channel is opened by calling <see cref="Start(Assembly)" />,
    /// passing the assembly returned by <see cref="Assembly.GetEntryAssembly()" />.  Although this should work
    /// fine for normal services and applications, it will not work in general for ASP.NET applications
    /// (since the entry assembly may be ASP.NET or another application host).
    /// </para>
    /// <para>
    /// The best practice for non-native LillTek applications is to explicitly call <see cref="Start()" />,
    /// <see cref="Start(Assembly)" />, or <see cref="StartWeb" /> during application initialization
    /// and <see cref="Stop()" /> just before the application terminates.
    /// </para>
    /// </remarks>
    public static class ChannelHost
    {
        //---------------------------------------------------------------------
        // Private classes

        private sealed class LockRoot : ILockable
        {
            //---------------------------------------------------------------------
            // ILockable implementation

            private object lockKey = TimedLock.AllocLockKey();

            /// <summary>
            /// Used by <see cref="TimedLock" /> to provide better deadlock
            /// diagnostic information.
            /// </summary>
            /// <returns>The process unique lock key for this instance.</returns>
            public object GetLockKey()
            {
                return lockKey;
            }
        }

        //---------------------------------------------------------------------
        // Implementation

        /// <summary>
        /// Passed to <see cref="TimedLock" /> to synchronize global state changes within the assembly.
        /// </summary>
        internal static readonly object SyncRoot = new LockRoot();

        private static int              refCount = 0;   // Start() reference count

        /// <summary>
        /// Used by services and applications to start the <see cref="ChannelHost" />,
        /// using the result of <see cref="Assembly" />.<see cref="Assembly.GetEntryAssembly" /> 
        /// to determine the location of the application configuration file.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Calls to this method may be nested.  A reference count is maintained and only
        /// the first call will actually perform any initialization.
        /// </para>
        /// <note>
        /// All successful calls to <see cref="Start()" /> must eventually be matched with
        /// a call to <see cref="Stop" /> global state including the underlying LillTek
        /// <see cref="MsgRouter" /> will be released properly.
        /// </note>
        /// </remarks>
        public static void Start()
        {
            using (TimedLock.Lock(SyncRoot))
            {
                if (refCount == 0)
                {
                    if (!Helper.IsInitialized)
                    {
                        Assembly entryAssembly = Assembly.GetEntryAssembly();

                        if (entryAssembly == null)
                        {
                            SysLog.LogWarning("Unable obtain the entry assembly via Assembly.GetEntryAssembly().  " +
                                              "The application's LillTek configuration settings will not be available.  " +
                                              "You may call LillTek.ServiceModel.ChannelHost.Start(Assembly) with a valid " +
                                              "assembly during application initialization to correct this.");

                            entryAssembly = Assembly.GetExecutingAssembly();    // Use the current assembly instead
                        }

                        Helper.InitializeApp(entryAssembly);
                    }

                    RegisterMsgTypes();
                    MsgRouter.StartGlobal();
                }

                refCount++;
            }
        }

        /// <summary>
        /// Used by services and applications to start the <see cref="ChannelHost" />,
        /// using the <see cref="Assembly" /> passed to determine the location of the application 
        /// configuration file.
        /// </summary>
        /// <param name="entryAssembly">The entry <see cref="Assembly" />.</param>
        /// <remarks>
        /// <para>
        /// Calls to this method may be nested.  A reference count is maintained and only
        /// the first call will actually perform any initialization.
        /// </para>
        /// <note>
        /// All successful calls to <see cref="Start(Assembly)" /> must eventually be matched with
        /// a call to <see cref="Stop" /> global state including the underlying LillTek
        /// <see cref="MsgRouter" /> will be released properly.
        /// </note>
        /// </remarks>
        public static void Start(Assembly entryAssembly)
        {
            using (TimedLock.Lock(SyncRoot))
            {
                if (refCount == 0)
                {
                    if (!Helper.IsInitialized)
                        Helper.InitializeApp(entryAssembly);

                    RegisterMsgTypes();
                    MsgRouter.StartGlobal();
                }

                refCount++;
            }
        }

        /// <summary>
        /// Used by ASP.NET applications to start the <see cref="ChannelHost" />.
        /// </summary>
        /// <param name="entryAssembly">The assembly containing the application's entry point.</param>
        /// <param name="rootPath">The fully qualified physical path to the application root folder.</param>
        /// <param name="aspAppName">The ASP.NET application name.</param>
        /// <remarks>
        /// <para>
        /// Calls to this method may be nested.  A reference count is maintained and only
        /// the first call will actually perform any initialization.
        /// </para>
        /// <note>
        /// All successful calls to <see cref="StartWeb" /> must eventually be matched with
        /// a call to <see cref="Stop" /> global state including the underlying LillTek
        /// <see cref="MsgRouter" /> will be released properly.
        /// </note>
        /// </remarks>
        public static void StartWeb(Assembly entryAssembly, string rootPath, string aspAppName)
        {
            using (TimedLock.Lock(SyncRoot))
            {
                if (refCount == 0)
                {
                    if (!Helper.IsInitialized)
                        Helper.InitializeWebApp(entryAssembly, rootPath, aspAppName);

                    RegisterMsgTypes();
                    MsgRouter.StartGlobal();
                }

                refCount++;
            }
        }

        /// <summary>
        /// Stops the channel host, if it is currently running.
        /// </summary>
        public static void Stop()
        {
            using (TimedLock.Lock(SyncRoot))
            {

                if (refCount == 0)
                    throw new InvalidOperationException("Reference count underflow.  Call to Stop() does not match a call to Start() or StartWeb().");

                refCount--;

                if (refCount == 0)
                    MsgRouter.StopGlobal();
            }
        }

        private static bool msgRegistered = false;  // True if the messages have been registered

        /// <summary>
        /// Handles the registration of the assembly's message types with the 
        /// LillTek.Messaging subsystem.
        /// </summary>
        /// <remarks>
        /// <note>
        /// This method ensures that messages are registered only once.  It's
        /// not a big performance hit to call this multiple times.
        /// </note>
        /// </remarks>
        internal static void RegisterMsgTypes()
        {
            using (TimedLock.Lock(SyncRoot))
            {
                if (msgRegistered)
                    return;

                Msg.LoadTypes(Assembly.GetExecutingAssembly());
            }
        }

        /// <summary>
        /// Returns the host's <see cref="MsgRouter" /> if one is running, <c>null</c> otherwise.
        /// </summary>
        public static MsgRouter Router
        {
            get { return MsgRouter.Global; }
        }
    }
}
