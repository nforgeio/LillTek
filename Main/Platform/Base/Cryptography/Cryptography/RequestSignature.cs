//-----------------------------------------------------------------------------
// FILE:        RequestSignature.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:   Copyright (c) 2005-2015 by Jeffrey Lill.  All rights reserved.
// DESCRIPTION: Used to authenticate the source of a request and also that 
//              the request parameters have not been tampered with.

using System;
using System.Collections.Generic;
using System.IO;
using System.Security;
using System.Security.Cryptography;
using System.Text;

using LillTek.Common;

namespace LillTek.Cryptography
{
    /// <summary>
    /// Used to authenticate the source of a request and also that 
    /// the request parameters have not been tampered with.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This class uses a shared <see cref="SymmetricKey" /> to generate an
    /// encrypted record containing the SHA-1 hash the request parameters
    /// as well as the request time (UTC).  Call the static <see cref="Generate" />
    /// method to generate a base 64 encoded signature, by passing the shared
    /// key and a dictionary holding the request parameters (note that the
    /// signature includes the current time (UTC)).  Then include
    /// the signature with the request being made to the remote program.
    /// </para>
    /// <para>
    /// The program receiving the request will call <see cref="Verify" /> or 
    /// <see cref="TryVerify" /> to validate the signature against the
    /// actual parameters received as well as the current server time.
    /// If the parameter signatures don't match or and the time recorded in 
    /// the signature falls outside the grace period around the current
    /// server time, then verification will fail.
    /// </para>
    /// <para>
    /// Here's the format for signature before it is encrypted:
    /// </para>
    /// <code language="none">
    /// +----------------+
    /// |      Salt      |  8-bytes:    Cryptographic salt
    /// +----------------+
    /// |      Magic     |  32-bits:    0x775512FE
    /// +----------------+
    /// |      Time      |  64-bits:    Request time UTC (ticks)
    /// +----------------+
    /// |                |
    /// |                |
    /// |   SHA-1 Hash   |  20-bytes:   SHA-1 hash of the normalalized
    /// |                |              request arguments
    /// |                |
    /// +----------------+
    ///   40 bytes total
    /// </code>
    /// <para>
    /// The request arguments are passed to the class as a string dictionary of
    /// name/value pairs.  These arguments are converted into a canonical form
    /// by the class before the SHA-1 hash is computed.  Here's the algorithm:
    /// </para>
    /// <list type="number">
    ///     <item>
    ///     The arguments are sorted ascending order by name (converted to lower case).
    ///     </item>
    ///     <item>
    ///     A string is generated by concatenating all of the argument values
    ///     in sorted order, separated by commas.
    ///     </item>
    ///     <item>
    ///     The string is converted to a byte array using UTF-8 encoding.
    ///     </item>
    ///     <item>
    ///     The SHA-1 hash is computed over the byte array.
    ///     </item>
    /// </list>
    /// </remarks>
    public static class RequestSignature
    {
        private const int Magic = 0x775512FE;
        private const int Size = 40;

        /// <summary>
        /// Computes the SHA-1 hash for the arguments.
        /// </summary>
        /// <param name="args">The request arguments.</param>
        /// <param name="signatureKey">The name of the signature if present in the arguments (or <c>null</c>).</param>
        /// <returns>The computed hash.</returns>
        private static byte[] ComputeHash(ArgCollection args, string signatureKey)
        {
            var sorted = new SortedList<string, string>();
            var sb = new StringBuilder(512);

            foreach (string key in args)
            {
                var lwrKey = key.ToLowerInvariant();

                if (signatureKey != null && String.Compare(signatureKey, key, true) == 0)
                    continue;   // Don't include the signature

                if (sorted.ContainsKey(lwrKey))
                    throw new ArgumentException(string.Format("RequestSignature supports case insensitive arguments only. The argument [name={0}] has multiple entries.", key));

                sorted.Add(lwrKey, args[key]);
            }

            bool first = true;

            foreach (string value in sorted.Values)
            {
                if (first)
                    first = false;
                else
                    sb.Append(',');

                sb.Append(value);
            }

            return SHA1Hasher.Compute(sb.ToString());
        }

        /// <summary>
        /// Generates a request signature using a shared <see cref="SymmetricKey" />
        /// for request arguments as well as the current time.
        /// </summary>
        /// <param name="sharedKey">The shared <see cref="SymmetricKey" />.</param>
        /// <param name="args">The request argument collection.</param>
        /// <returns>The base-64 encoded signature.</returns>
        public static string Generate(SymmetricKey sharedKey, ArgCollection args)
        {
            using (var ms = new EnhancedMemoryStream(512))
            {
                ms.WriteBytesNoLen(Crypto.GetSalt8());
                ms.WriteInt32(Magic);
                ms.WriteInt64(DateTime.UtcNow.Ticks);
                ms.WriteBytesNoLen(ComputeHash(args, null));

                return Convert.ToBase64String(Crypto.Encrypt(ms.ToArray(), sharedKey));
            }
        }

        /// <summary>
        /// Verifies request arguments against a signature using a shared <see cref="SymmetricKey" />
        /// and the current time.
        /// </summary>
        /// <param name="sharedKey">The shared <see cref="SymmetricKey" />.</param>
        /// <param name="signature">The base-64 encoded signature.</param>
        /// <param name="args">The request argument collection.</param>
        /// <param name="signatureKey">
        /// The name of the signature key within the event arguments or <c>null</c>
        /// if the signature is not present.
        /// </param>
        /// <param name="graceInterval">Specifies the time period used for verifying the signature request time.</param>
        /// <exception cref="SecurityException">Thrown if the signature could not be verified.</exception>
        /// <remarks>
        /// <para>
        /// <paramref name="graceInterval" /> is used when comparing the request time (UTC) embedded
        /// in the signature with the current machine time (UTC).  Request times within the range of:
        /// </para>
        /// <code language="none">
        /// DateTime.UtcNow - graceInterval &lt;= requestTime &lt;= DateTime.UtcNow + graceInterval
        /// </code>
        /// <para>
        /// will be considered to be valid.  Request times outside this range will be invalid.
        /// Larger grace intervals provide help avoid the problems of incorrect system times or
        /// long request delivery delays but at the price of the increased exposure to replay
        /// attacks.
        /// </para>
        /// <note>
        /// If the signature is present in the arguments, then the <paramref name="signatureKey" /> <b>must</b>
        /// be passed as its name or else the verification will always fail.  The reason for this is
        /// that the hash was originally computed before the signature was added so the hash will be
        /// different if it includes the signature.
        /// </note>
        /// </remarks>
        public static void Verify(SymmetricKey sharedKey, string signature, ArgCollection args, string signatureKey, TimeSpan graceInterval)
        {
            if (!TryVerify(sharedKey, signature, args, signatureKey, graceInterval))
                throw new SecurityException("Access denied.");
        }

        /// <summary>
        /// Verifies request arguments against a signature using a shared <see cref="SymmetricKey" />
        /// and the current time.
        /// </summary>
        /// <param name="sharedKey">The shared <see cref="SymmetricKey" />.</param>
        /// <param name="signature">The base-64 encoded signature.</param>
        /// <param name="args">The request argument collection.</param>
        /// <param name="signatureKey">
        /// The name of the signature key within the event arguments or <c>null</c>
        /// if the signature is not present.
        /// </param>
        /// <param name="graceInterval">Specifies the time period used for verifying the signature request time.</param>
        /// <returns><c>true</c> if the signature is valid.</returns>
        /// <remarks>
        /// <para>
        /// <paramref name="graceInterval" /> is used when comparing the request time (UTC) embedded
        /// in the signature with the current machine time (UTC).  Request times within the range of:
        /// </para>
        /// <code language="none">
        /// DateTime.UtcNow - graceInterval &lt;= requestTime &lt;= DateTime.UtcNow + graceInterval
        /// </code>
        /// <para>
        /// will be considered to be valid.  Request times outside this range will be invalid.
        /// Larger grace intervals provide help avoid the problems of incorrect system times or
        /// long request delivery delays but at the price of the increased exposure to replay
        /// attacks.
        /// </para>
        /// <note>
        /// If the signature is present in the arguments, then the <paramref name="signatureKey" /> <b>must</b>
        /// be passed as its name or else the verification will always fail.  The reason for this is
        /// that the hash was originally computed before the signature was added so the hash will be
        /// different if it includes the signature.
        /// </note>
        /// </remarks>
        public static bool TryVerify(SymmetricKey sharedKey, string signature, ArgCollection args, string signatureKey, TimeSpan graceInterval)
        {
            try
            {
                byte[]       encrypted = Convert.FromBase64String(signature);
                byte[]      decrypted;
                byte[]      requestHash;
                byte[]      hash;
                DateTime    requestTime;
                DateTime    now;

                decrypted = Crypto.Decrypt(encrypted, sharedKey);
                if (decrypted.Length != Size)
                    return false;

                using (var ms = new EnhancedMemoryStream(decrypted))
                {
                    ms.Position = 8;
                    if (ms.ReadInt32() != Magic)
                        return false;

                    requestTime = new DateTime(ms.ReadInt64());
                    requestHash = ms.ReadBytes(SHA1Hasher.DigestSize);
                }

                now = DateTime.UtcNow;
                if (!Helper.Within(requestTime, now, graceInterval))
                    return false;

                hash = ComputeHash(args, signatureKey);
                return Helper.ArrayEquals(requestHash, hash);
            }
            catch
            {
                return false;
            }
        }
    }
}
