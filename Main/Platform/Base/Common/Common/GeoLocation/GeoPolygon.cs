//-----------------------------------------------------------------------------
// FILE:        GeoPolygon.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:   Copyright (c) 2005-2015 by Jeffrey Lill.  All rights reserved.
// DESCRIPTION: Defines a geographical polygon from an ordered set of GeoCoordinates
//              defining the vertices.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LillTek.Common
{
    /// <summary>
    /// Defines a geographical polygon from an ordered set of <see cref="GeoCoordinate" />s
    /// defining the vertices.
    /// </summary>
    public sealed class GeoPolygon : GeoRegion
    {

        private IList<GeoCoordinate> vertices;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="vertices">The ordered set <see cref="GeoCoordinate" />s defining the poloygon's vertices.</param>
        /// <exception cref="ArgumentNullException">Thrown if <paramref name="vertices" /> is <c>null</c>.</exception>
        /// <remarks>
        /// <note>
        /// The set of vertices should include wind around the polygon.  The last vertex will
        /// be implicitly connected to the first.  You may pass the starting vertex as the last
        /// point, but the class will remove it.
        /// </note>
        /// <note>
        /// A single vertex may be passed.  This essentially defines a point.  The constructor
        /// will assume a single vertex of (0,0) if no vertices are passed.
        /// </note>
        /// <note>
        /// <b><font color="red">Warning:</font></b> LillTek geographical classes support
        /// Euclidean geometry and do not currently support planar wraparound at the 180th
        /// meridian (opposite of the Prime Merdian) or at the poles.
        /// </note>
        /// </remarks>
        public GeoPolygon(IEnumerable<GeoCoordinate> vertices)
        {
            Initialize(vertices);
        }

        /// <summary>
        /// Deserializes the instance from a string generated by a previous call to <see cref="ToString" />.
        /// </summary>
        /// <param name="input">The serialized region.</param>
        /// <exception cref="ArgumentException">Thrown if the input is not valid.</exception>
        internal GeoPolygon(string input)
        {
            List<GeoCoordinate>     vertices;
            string                  key;
            int                     pos;
            string[]                fields;
            string[]                latLon;

            if (input == null)
                throw new ArgumentNullException("input");

            try
            {
                pos = input.IndexOf(':');
                if (pos == -1)
                    throw new ArgumentException();

                key = input.Substring(0, pos);
                if (String.Compare(key, GeoRegion.PolygonRegionKey, StringComparison.OrdinalIgnoreCase) != 0)
                    throw new ArgumentException();

                // Expecting the fields to be formatted as comma separated vertices
                // each formatted as: lat:lon

                fields = input.Substring(pos + 1).Split(',');
                if (fields.Length == 0)
                    throw new ArgumentException();

                vertices = new List<GeoCoordinate>(fields.Length - 1);

                for (int i = 0; i < fields.Length; i++)
                {
                    latLon = fields[i].Split(':');
                    if (latLon.Length == 0)
                        break;      // Tolerate an extra comma at the end

                    vertices.Add(new GeoCoordinate(latLon[0], latLon[1]));
                }

                Initialize(vertices);
            }
            catch (Exception e)
            {
                throw new ArgumentException(string.Format("GeoPolygon: Cannot deserialize [{0}].", input), e);
            }
        }

        /// <summary>
        /// Initializes the instance.
        /// </summary>
        /// <param name="vertices">The vertices.</param>
        private void Initialize(IEnumerable<GeoCoordinate> vertices)
        {
            List<GeoCoordinate>     temp;
            int                     count;
            GeoCoordinate           firstVertex;
            GeoCoordinate           lastVertex;
            bool                    gotFirst;
            double                  left;
            double                  top;
            double                  right;
            double                  bottom;
            int                     i;

            if (vertices == null)
                throw new ArgumentNullException("verticies");

            firstVertex =
            lastVertex = GeoCoordinate.Origin;
            gotFirst = false;
            count = 0;

            foreach (var vertex in vertices)
            {
                if (!gotFirst)
                {
                    firstVertex = vertex;
                    gotFirst = true;
                }

                lastVertex = vertex;
                count++;
            }

            if (count <= 1)
            {
                temp = new List<GeoCoordinate>(1);
                temp.Add(firstVertex);

                left = right = firstVertex.Longitude;
                top   = bottom = firstVertex.Latitude;
            }
            else if (firstVertex == lastVertex)
            {
                // The application wrapped all the way around back to the
                // starting vertex.  We're going to ignore the last point.

                right  =
                left   = firstVertex.Longitude;
                top    =
                bottom = firstVertex.Latitude;

                temp = new List<GeoCoordinate>(count - 1);
                i = 0;
                foreach (var vertex in vertices)
                {
                    if (++i == count)
                        break;  // Ignore the last vertex

                    temp.Add(vertex);

                    left   = Math.Max(left, vertex.Longitude);
                    right  = Math.Min(right, vertex.Longitude);
                    top    = Math.Max(top, vertex.Latitude);
                    bottom = Math.Min(bottom, vertex.Latitude);
                }
            }
            else
            {

                right  =
                left   = firstVertex.Longitude;
                top    =
                bottom = firstVertex.Latitude;

                temp = new List<GeoCoordinate>(count);
                foreach (var vertex in vertices)
                {
                    temp.Add(vertex);

                    left   = Math.Max(left, vertex.Longitude);
                    right  = Math.Min(right, vertex.Longitude);
                    top    = Math.Max(top, vertex.Latitude);
                    bottom = Math.Min(bottom, vertex.Latitude);
                }
            }

            this.vertices = temp.AsReadOnly();
            base.Bounds   = new GeoRectangle(new GeoCoordinate(top, left), new GeoCoordinate(bottom, right));
        }

        /// <summary>
        /// Returns an ordered read-only list of the polygon's verticies.
        /// </summary>
        public IList<GeoCoordinate> Vertices
        {
            get { return vertices; }
        }

        /// <summary>
        /// Returns <c>true</c> if the polygon consists of only a single vertex.
        /// </summary>
        public bool IsPoint
        {
            get { return vertices.Count == 1; }
        }

        /// <summary>
        /// Determines whether a point is within the polygon.
        /// </summary>
        /// <param name="point">The point being tested.</param>
        /// <returns><c>true</c> if the point is within the polygon.</returns>
        public override bool Contains(GeoCoordinate point)
        {
            if (vertices.Count == 1)
                return point == vertices[0];
            else if (!Bounds.Contains(point))
                return false;

            // The code below is adapted from Javascript found on a Microsoft sample:
            //
            //      http://msdn.microsoft.com/en-us/library/cc451895.aspx
            //
            // The algorithm basically implicitly draws an infinite line through the point
            // and then counts how many times the line crosses and edge of the polygon.
            // If the number of crossings is odd, the point is within the polygon.

            double      lat    = point.Latitude;
            double      lon    = point.Longitude;
            int         j      = vertices.Count - 1;
            bool        inside = false;
            int         i;

            for (i = 0; i < vertices.Count; i++)
            {
                if (vertices[i].Longitude < lon && vertices[j].Longitude >= lon || vertices[j].Longitude < lon && vertices[i].Longitude >= lon)
                {
                    if (vertices[i].Latitude + (lon - vertices[i].Longitude) / (vertices[j].Longitude - vertices[i].Longitude) * (vertices[j].Latitude - vertices[i].Latitude) < lat)
                        inside = !inside;
                }

                j = i;
            }

            return inside;
        }

        /// <summary>
        /// Serializes the region into a form suitable for transmission or writing
        /// to persistant storage.
        /// </summary>
        /// <returns>The serialized region.</returns>
        public override string ToString()
        {
            var sb    = new StringBuilder();
            var first = true;

            sb.AppendFormat("{0}:", GeoRegion.PolygonRegionKey);

            foreach (var vertex in vertices)
            {
                if (first)
                    first = false;
                else
                    sb.Append(',');

                sb.AppendFormat("{0}:{1}", vertex.Latitude, vertex.Longitude);
            }

            return sb.ToString();
        }
    }
}

