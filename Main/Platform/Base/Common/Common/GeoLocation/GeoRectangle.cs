//-----------------------------------------------------------------------------
// FILE:        GeoRectangle.cs
// CONTRIBUTOR: Jeff Lill
// COPYRIGHT:   Copyright (c) 2005-2015 by Jeffrey Lill.  All rights reserved.
// DESCRIPTION: Defines a geographical rectangle via its northeast 
//              southwest corners.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LillTek.Common
{
    /// <summary>
    /// Defines a geographical rectangle via its northeast and southwest corners.
    /// </summary>
    /// <remarks>
    /// <note>
    /// <b><font color="red">Warning:</font></b> LillTek geographical classes support
    /// Euclidean geometry and do not currently support wraparound at the 180th
    /// meridian (opposite of the Prime Merdian) or at the poles.
    /// </note>
    /// </remarks>
    public sealed class GeoRectangle : GeoRegion
    {
        //---------------------------------------------------------------------
        // Static members

        /// <summary>
        /// Determines if two rectangles are equal.
        /// </summary>
        /// <param name="r1">Rectangle one.</param>
        /// <param name="r2">Rectangle two</param>
        /// <returns><c>true</c> if the rectangles are not equal.</returns>
        public static bool operator ==(GeoRectangle r1, GeoRectangle r2)
        {
            if ((object)r1 == null && (object)r2 == null)
                return true;
            else if ((object)r1 == null || (object)r2 == null)
                return false;

            return r1.Northeast == r2.Northeast && r1.Southwest == r2.Southwest;
        }

        /// <summary>
        /// Determines if two rectangles are not equal.
        /// </summary>
        /// <param name="r1">Rectangle one.</param>
        /// <param name="r2">Rectangle two</param>
        /// <returns><c>true</c> if the rectangles are equal.</returns>
        public static bool operator !=(GeoRectangle r1, GeoRectangle r2)
        {
            if ((object)r1 == null && (object)r2 == null)
                return false;
            else if ((object)r1 == null || (object)r2 == null)
                return true;

            return r1.Northeast != r2.Northeast || r1.Southwest != r2.Southwest;
        }

        //---------------------------------------------------------------------
        // Instance members

        private GeoCoordinate   nePoint;
        private GeoCoordinate   swPoint;

        /// <summary>
        /// Constructs a rectangle from <see cref="GeoCoordinate" />s of the NE and SW corners.
        /// </summary>
        /// <param name="northEast">The northeast corner.</param>
        /// <param name="southWest">The southwest corner.</param>
        /// <exception cref="ArgumentException">Thrown if the rectangle wraps around the 180th meridian, the north or south poles.</exception>
        public GeoRectangle(GeoCoordinate northEast, GeoCoordinate southWest)
        {
            nePoint = northEast;
            swPoint = southWest;

            CheckForWraparound();

            base.Bounds = this;
        }

        /// <summary>
        /// Constructs a rectangle from double coordinates of the NE and SW corners.
        /// </summary>
        /// <param name="neLatitude">Latitude of the NE corner.</param>
        /// <param name="neLongitude">Longitude of the NE corner.</param>
        /// <param name="swLatitude">Latitude of the SW corner.</param>
        /// <param name="swLongitude">Longitude of the SW corner.</param>
        /// <exception cref="ArgumentException">Thrown if the rectangle wraps around the 180th meridian, the north or south poles.</exception>
        public GeoRectangle(double neLatitude, double neLongitude, double swLatitude, double swLongitude)
        {
            nePoint = new GeoCoordinate(neLatitude, neLongitude);
            swPoint = new GeoCoordinate(swLatitude, swLongitude);

            CheckForWraparound();

            base.Bounds = this;
        }

        /// <summary>
        /// Deserializes the instance from a string generated by a previous call to <see cref="ToString" />.
        /// </summary>
        /// <param name="input">The serialized region.</param>
        /// <exception cref="ArgumentException">Thrown if the input is not valid.</exception>
        internal GeoRectangle(string input)
        {
            string      key;
            int         pos;
            string[]    fields;
            string[]    latLon;

            if (input == null)
                throw new ArgumentNullException("input");

            try
            {
                pos = input.IndexOf(':');
                if (pos == -1)
                    throw new ArgumentException();

                key = input.Substring(0, pos);
                if (String.Compare(key, GeoRegion.RectangleRegionKey, StringComparison.OrdinalIgnoreCase) != 0)
                    throw new ArgumentException();

                // Expecting the fields to be formatted as: neLat:nelon,swLat,swLon

                fields = input.Substring(pos + 1).Split(',');
                if (fields.Length != 2)
                    throw new ArgumentException();

                latLon = fields[0].Split(':');
                if (latLon.Length != 2)
                    throw new ArgumentException();

                nePoint = new GeoCoordinate(latLon[0], latLon[1]);

                latLon = fields[1].Split(':');
                if (latLon.Length != 2)
                    throw new ArgumentException();

                swPoint = new GeoCoordinate(latLon[0], latLon[1]);
            }
            catch (Exception e)
            {
                throw new ArgumentException(string.Format("GeoRectangle: Cannot deserialize [{0}].", input), e);
            }

            CheckForWraparound();

            base.Bounds = this;
        }

        /// <summary>
        /// Checks the coordinates for wraparound.
        /// </summary>
        private void CheckForWraparound()
        {
            if (nePoint.Latitude < swPoint.Latitude || nePoint.Longitude < swPoint.Longitude)
                throw new ArgumentException(string.Format("GeoRectangle: The coordinates [{0}:{1},{2}:{3}] wraparound the 180th meridian, the north, or the south poles.",
                                                          nePoint.Latitude, nePoint.Longitude, swPoint.Latitude, swPoint.Longitude));
        }

        /// <summary>
        /// Returns the northeast corner of the rectangle.
        /// </summary>
        public GeoCoordinate Northeast
        {
            get { return nePoint; }
        }

        /// <summary>
        /// Returns the southwest corner of the rectangle.
        /// </summary>
        public GeoCoordinate Southwest
        {
            get { return swPoint; }
        }

        /// <summary>
        /// Returns the leftmost coordinate of the rectangle.
        /// </summary>
        public double Left
        {
            get { return swPoint.Longitude; }
        }

        /// <summary>
        /// Returns the topmost coordinate of the rectangle.
        /// </summary>
        public double Top
        {
            get { return nePoint.Latitude; }
        }

        /// <summary>
        /// Returns the rightmost coordinate of the rectangle.
        /// </summary>
        public double Right
        {
            get { return nePoint.Longitude; }
        }

        /// <summary>
        /// Returns the bottommost coordinate of the rectangle.
        /// </summary>
        public double Bottom
        {
            get { return swPoint.Latitude; }
        }

        /// <summary>
        /// Returns the height of the rectangle (in degrees).
        /// </summary>
        public double Width
        {
            get { return nePoint.Latitude - swPoint.Latitude; }
        }

        /// <summary>
        /// Returns the width of the rectangle (in degrees).
        /// </summary>
        public double Height
        {
            get { return nePoint.Longitude - swPoint.Longitude; }
        }

        /// <summary>
        /// Returns <c>true</c> if the rectangle is empty (or is essentially just a point in space).
        /// </summary>
        public bool IsEmpty
        {
            get { return nePoint == swPoint; }
        }

        /// <summary>
        /// Determines whether a point is within the rectangle.
        /// </summary>
        /// <param name="point">The point being tested.</param>
        /// <returns><c>true</c> if the point is within the rectangle.</returns>
        public override bool Contains(GeoCoordinate point)
        {
            return swPoint.Longitude <= point.Longitude && point.Longitude <= nePoint.Longitude &&
                   nePoint.Latitude >= point.Latitude && point.Latitude >= swPoint.Latitude;
        }

        /// <summary>
        /// Determines whether a rectangle intersects this rectangle.
        /// </summary>
        /// <param name="r">The rectangle to test.</param>
        /// <returns><c>true</c> if the rectangles intersect.</returns>
        public bool IntersectsWith(GeoRectangle r)
        {
            // Determine whether the test rectangle is completely inside of this
            // rectangle.

            if (this.Left <= r.Left && r.Right <= this.Right && this.Top >= r.Top && r.Bottom <= this.Bottom)
                return true;

            // Determine whether this rectangle is completely inside of the
            // test rectangle.

            if (r.Left <= this.Left && this.Right <= r.Right && r.Top >= this.Top && this.Bottom <= r.Bottom)
                return true;

            // Determine whether the rectangle is completely outside of the
            // current rectangle.

            return !(this.Left > r.Right ||
                     this.Right < r.Left ||
                     this.Top > r.Bottom ||
                     this.Bottom < r.Top);
        }

        /// <summary>
        /// Returns a new rectangle by offsetting the current rectangle's latitude and
        /// longitude coordinates by specified distances.
        /// </summary>
        /// <param name="dLatitude">The distance to shift the latitude (in degrees).</param>
        /// <param name="dLongitude">The distance to shift the longitude (in degrees).</param>
        /// <returns>The new rectangle.</returns>
        /// <exception cref="ArgumentException">Thrown if the resulting rectangle is off the map.</exception>
        public GeoRectangle Translate(double dLatitude, double dLongitude)
        {
            return new GeoRectangle(Northeast.Latitude + dLatitude, Northeast.Longitude + dLongitude,
                                    Southwest.Latitude + dLatitude, Southwest.Longitude + dLongitude);
        }

        /// <summary>
        /// Determines whether another object instance equals this instance.
        /// </summary>
        /// <param name="obj">The other instance.</param>
        /// <returns><c>true</c> if the objects are equal.</returns>
        public override bool Equals(object obj)
        {
            var r = obj as GeoRectangle;

            if (object.ReferenceEquals(r, null))
                return false;

            return r.Northeast == this.Northeast && r.Southwest == this.Southwest;
        }

        /// <summary>
        /// Computes the hash code for the instance.
        /// </summary>
        /// <returns>The hash code.</returns>
        public override int GetHashCode()
        {
            return nePoint.GetHashCode() ^ swPoint.GetHashCode();
        }

        /// <summary>
        /// Serializes the region into a form suitable for transmission or writing
        /// to persistant storage.
        /// </summary>
        /// <returns>The serialized region.</returns>
        public override string ToString()
        {
            return string.Format("{0}:{1}:{2},{3}:{4}", GeoRegion.RectangleRegionKey, nePoint.Latitude, nePoint.Longitude, swPoint.Latitude, swPoint.Longitude);
        }
    }
}
